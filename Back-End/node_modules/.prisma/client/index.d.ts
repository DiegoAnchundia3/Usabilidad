
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Animal
 * 
 */
export type Animal = $Result.DefaultSelection<Prisma.$AnimalPayload>
/**
 * Model Adopcion
 * 
 */
export type Adopcion = $Result.DefaultSelection<Prisma.$AdopcionPayload>
/**
 * Model HistoriaExito
 * 
 */
export type HistoriaExito = $Result.DefaultSelection<Prisma.$HistoriaExitoPayload>
/**
 * Model Donacion
 * 
 */
export type Donacion = $Result.DefaultSelection<Prisma.$DonacionPayload>
/**
 * Model RegistroMedico
 * 
 */
export type RegistroMedico = $Result.DefaultSelection<Prisma.$RegistroMedicoPayload>
/**
 * Model Voluntariado
 * 
 */
export type Voluntariado = $Result.DefaultSelection<Prisma.$VoluntariadoPayload>
/**
 * Model HogarTemporal
 * 
 */
export type HogarTemporal = $Result.DefaultSelection<Prisma.$HogarTemporalPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.animal`: Exposes CRUD operations for the **Animal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Animals
    * const animals = await prisma.animal.findMany()
    * ```
    */
  get animal(): Prisma.AnimalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adopcion`: Exposes CRUD operations for the **Adopcion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Adopcions
    * const adopcions = await prisma.adopcion.findMany()
    * ```
    */
  get adopcion(): Prisma.AdopcionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.historiaExito`: Exposes CRUD operations for the **HistoriaExito** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistoriaExitos
    * const historiaExitos = await prisma.historiaExito.findMany()
    * ```
    */
  get historiaExito(): Prisma.HistoriaExitoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.donacion`: Exposes CRUD operations for the **Donacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donacions
    * const donacions = await prisma.donacion.findMany()
    * ```
    */
  get donacion(): Prisma.DonacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registroMedico`: Exposes CRUD operations for the **RegistroMedico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegistroMedicos
    * const registroMedicos = await prisma.registroMedico.findMany()
    * ```
    */
  get registroMedico(): Prisma.RegistroMedicoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.voluntariado`: Exposes CRUD operations for the **Voluntariado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Voluntariados
    * const voluntariados = await prisma.voluntariado.findMany()
    * ```
    */
  get voluntariado(): Prisma.VoluntariadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hogarTemporal`: Exposes CRUD operations for the **HogarTemporal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HogarTemporals
    * const hogarTemporals = await prisma.hogarTemporal.findMany()
    * ```
    */
  get hogarTemporal(): Prisma.HogarTemporalDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Animal: 'Animal',
    Adopcion: 'Adopcion',
    HistoriaExito: 'HistoriaExito',
    Donacion: 'Donacion',
    RegistroMedico: 'RegistroMedico',
    Voluntariado: 'Voluntariado',
    HogarTemporal: 'HogarTemporal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "usuario" | "animal" | "adopcion" | "historiaExito" | "donacion" | "registroMedico" | "voluntariado" | "hogarTemporal"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Animal: {
        payload: Prisma.$AnimalPayload<ExtArgs>
        fields: Prisma.AnimalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          findFirst: {
            args: Prisma.AnimalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          findMany: {
            args: Prisma.AnimalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>[]
          }
          create: {
            args: Prisma.AnimalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          createMany: {
            args: Prisma.AnimalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>[]
          }
          delete: {
            args: Prisma.AnimalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          update: {
            args: Prisma.AnimalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          deleteMany: {
            args: Prisma.AnimalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnimalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>[]
          }
          upsert: {
            args: Prisma.AnimalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimalPayload>
          }
          aggregate: {
            args: Prisma.AnimalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnimal>
          }
          groupBy: {
            args: Prisma.AnimalGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimalGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimalCountArgs<ExtArgs>
            result: $Utils.Optional<AnimalCountAggregateOutputType> | number
          }
        }
      }
      Adopcion: {
        payload: Prisma.$AdopcionPayload<ExtArgs>
        fields: Prisma.AdopcionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdopcionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdopcionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>
          }
          findFirst: {
            args: Prisma.AdopcionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdopcionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>
          }
          findMany: {
            args: Prisma.AdopcionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>[]
          }
          create: {
            args: Prisma.AdopcionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>
          }
          createMany: {
            args: Prisma.AdopcionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdopcionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>[]
          }
          delete: {
            args: Prisma.AdopcionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>
          }
          update: {
            args: Prisma.AdopcionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>
          }
          deleteMany: {
            args: Prisma.AdopcionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdopcionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdopcionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>[]
          }
          upsert: {
            args: Prisma.AdopcionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdopcionPayload>
          }
          aggregate: {
            args: Prisma.AdopcionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdopcion>
          }
          groupBy: {
            args: Prisma.AdopcionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdopcionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdopcionCountArgs<ExtArgs>
            result: $Utils.Optional<AdopcionCountAggregateOutputType> | number
          }
        }
      }
      HistoriaExito: {
        payload: Prisma.$HistoriaExitoPayload<ExtArgs>
        fields: Prisma.HistoriaExitoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistoriaExitoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistoriaExitoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>
          }
          findFirst: {
            args: Prisma.HistoriaExitoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistoriaExitoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>
          }
          findMany: {
            args: Prisma.HistoriaExitoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>[]
          }
          create: {
            args: Prisma.HistoriaExitoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>
          }
          createMany: {
            args: Prisma.HistoriaExitoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistoriaExitoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>[]
          }
          delete: {
            args: Prisma.HistoriaExitoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>
          }
          update: {
            args: Prisma.HistoriaExitoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>
          }
          deleteMany: {
            args: Prisma.HistoriaExitoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistoriaExitoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HistoriaExitoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>[]
          }
          upsert: {
            args: Prisma.HistoriaExitoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistoriaExitoPayload>
          }
          aggregate: {
            args: Prisma.HistoriaExitoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistoriaExito>
          }
          groupBy: {
            args: Prisma.HistoriaExitoGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoriaExitoGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistoriaExitoCountArgs<ExtArgs>
            result: $Utils.Optional<HistoriaExitoCountAggregateOutputType> | number
          }
        }
      }
      Donacion: {
        payload: Prisma.$DonacionPayload<ExtArgs>
        fields: Prisma.DonacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          findFirst: {
            args: Prisma.DonacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          findMany: {
            args: Prisma.DonacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>[]
          }
          create: {
            args: Prisma.DonacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          createMany: {
            args: Prisma.DonacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DonacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>[]
          }
          delete: {
            args: Prisma.DonacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          update: {
            args: Prisma.DonacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          deleteMany: {
            args: Prisma.DonacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DonacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DonacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>[]
          }
          upsert: {
            args: Prisma.DonacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DonacionPayload>
          }
          aggregate: {
            args: Prisma.DonacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDonacion>
          }
          groupBy: {
            args: Prisma.DonacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DonacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DonacionCountArgs<ExtArgs>
            result: $Utils.Optional<DonacionCountAggregateOutputType> | number
          }
        }
      }
      RegistroMedico: {
        payload: Prisma.$RegistroMedicoPayload<ExtArgs>
        fields: Prisma.RegistroMedicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegistroMedicoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegistroMedicoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>
          }
          findFirst: {
            args: Prisma.RegistroMedicoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegistroMedicoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>
          }
          findMany: {
            args: Prisma.RegistroMedicoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>[]
          }
          create: {
            args: Prisma.RegistroMedicoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>
          }
          createMany: {
            args: Prisma.RegistroMedicoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegistroMedicoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>[]
          }
          delete: {
            args: Prisma.RegistroMedicoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>
          }
          update: {
            args: Prisma.RegistroMedicoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>
          }
          deleteMany: {
            args: Prisma.RegistroMedicoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegistroMedicoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegistroMedicoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>[]
          }
          upsert: {
            args: Prisma.RegistroMedicoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroMedicoPayload>
          }
          aggregate: {
            args: Prisma.RegistroMedicoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegistroMedico>
          }
          groupBy: {
            args: Prisma.RegistroMedicoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegistroMedicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegistroMedicoCountArgs<ExtArgs>
            result: $Utils.Optional<RegistroMedicoCountAggregateOutputType> | number
          }
        }
      }
      Voluntariado: {
        payload: Prisma.$VoluntariadoPayload<ExtArgs>
        fields: Prisma.VoluntariadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoluntariadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoluntariadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>
          }
          findFirst: {
            args: Prisma.VoluntariadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoluntariadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>
          }
          findMany: {
            args: Prisma.VoluntariadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>[]
          }
          create: {
            args: Prisma.VoluntariadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>
          }
          createMany: {
            args: Prisma.VoluntariadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoluntariadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>[]
          }
          delete: {
            args: Prisma.VoluntariadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>
          }
          update: {
            args: Prisma.VoluntariadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>
          }
          deleteMany: {
            args: Prisma.VoluntariadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoluntariadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoluntariadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>[]
          }
          upsert: {
            args: Prisma.VoluntariadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VoluntariadoPayload>
          }
          aggregate: {
            args: Prisma.VoluntariadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVoluntariado>
          }
          groupBy: {
            args: Prisma.VoluntariadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoluntariadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoluntariadoCountArgs<ExtArgs>
            result: $Utils.Optional<VoluntariadoCountAggregateOutputType> | number
          }
        }
      }
      HogarTemporal: {
        payload: Prisma.$HogarTemporalPayload<ExtArgs>
        fields: Prisma.HogarTemporalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HogarTemporalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HogarTemporalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>
          }
          findFirst: {
            args: Prisma.HogarTemporalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HogarTemporalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>
          }
          findMany: {
            args: Prisma.HogarTemporalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>[]
          }
          create: {
            args: Prisma.HogarTemporalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>
          }
          createMany: {
            args: Prisma.HogarTemporalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HogarTemporalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>[]
          }
          delete: {
            args: Prisma.HogarTemporalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>
          }
          update: {
            args: Prisma.HogarTemporalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>
          }
          deleteMany: {
            args: Prisma.HogarTemporalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HogarTemporalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HogarTemporalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>[]
          }
          upsert: {
            args: Prisma.HogarTemporalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HogarTemporalPayload>
          }
          aggregate: {
            args: Prisma.HogarTemporalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHogarTemporal>
          }
          groupBy: {
            args: Prisma.HogarTemporalGroupByArgs<ExtArgs>
            result: $Utils.Optional<HogarTemporalGroupByOutputType>[]
          }
          count: {
            args: Prisma.HogarTemporalCountArgs<ExtArgs>
            result: $Utils.Optional<HogarTemporalCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    usuario?: UsuarioOmit
    animal?: AnimalOmit
    adopcion?: AdopcionOmit
    historiaExito?: HistoriaExitoOmit
    donacion?: DonacionOmit
    registroMedico?: RegistroMedicoOmit
    voluntariado?: VoluntariadoOmit
    hogarTemporal?: HogarTemporalOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    adopciones: number
    donaciones: number
    voluntariados: number
    registrosMedicos: number
    hogaresTemporales: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adopciones?: boolean | UsuarioCountOutputTypeCountAdopcionesArgs
    donaciones?: boolean | UsuarioCountOutputTypeCountDonacionesArgs
    voluntariados?: boolean | UsuarioCountOutputTypeCountVoluntariadosArgs
    registrosMedicos?: boolean | UsuarioCountOutputTypeCountRegistrosMedicosArgs
    hogaresTemporales?: boolean | UsuarioCountOutputTypeCountHogaresTemporalesArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountAdopcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdopcionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDonacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonacionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountVoluntariadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoluntariadoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountRegistrosMedicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroMedicoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountHogaresTemporalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HogarTemporalWhereInput
  }


  /**
   * Count Type AnimalCountOutputType
   */

  export type AnimalCountOutputType = {
    adopciones: number
    historias: number
    registrosMedicos: number
    hogaresTemporales: number
  }

  export type AnimalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adopciones?: boolean | AnimalCountOutputTypeCountAdopcionesArgs
    historias?: boolean | AnimalCountOutputTypeCountHistoriasArgs
    registrosMedicos?: boolean | AnimalCountOutputTypeCountRegistrosMedicosArgs
    hogaresTemporales?: boolean | AnimalCountOutputTypeCountHogaresTemporalesArgs
  }

  // Custom InputTypes
  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimalCountOutputType
     */
    select?: AnimalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeCountAdopcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdopcionWhereInput
  }

  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeCountHistoriasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoriaExitoWhereInput
  }

  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeCountRegistrosMedicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroMedicoWhereInput
  }

  /**
   * AnimalCountOutputType without action
   */
  export type AnimalCountOutputTypeCountHogaresTemporalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HogarTemporalWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    id: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    telefono: string | null
    tipoUsuario: string | null
    estado: string | null
    avatar: string | null
    password: string | null
    fechaRegistro: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    email: string | null
    telefono: string | null
    tipoUsuario: string | null
    estado: string | null
    avatar: string | null
    password: string | null
    fechaRegistro: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    email: number
    telefono: number
    tipoUsuario: number
    estado: number
    avatar: number
    password: number
    fechaRegistro: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    id?: true
  }

  export type UsuarioSumAggregateInputType = {
    id?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    telefono?: true
    tipoUsuario?: true
    estado?: true
    avatar?: true
    password?: true
    fechaRegistro?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    telefono?: true
    tipoUsuario?: true
    estado?: true
    avatar?: true
    password?: true
    fechaRegistro?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    email?: true
    telefono?: true
    tipoUsuario?: true
    estado?: true
    avatar?: true
    password?: true
    fechaRegistro?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: number
    nombre: string
    apellido: string | null
    email: string
    telefono: string | null
    tipoUsuario: string
    estado: string
    avatar: string | null
    password: string
    fechaRegistro: Date
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    telefono?: boolean
    tipoUsuario?: boolean
    estado?: boolean
    avatar?: boolean
    password?: boolean
    fechaRegistro?: boolean
    adopciones?: boolean | Usuario$adopcionesArgs<ExtArgs>
    donaciones?: boolean | Usuario$donacionesArgs<ExtArgs>
    voluntariados?: boolean | Usuario$voluntariadosArgs<ExtArgs>
    registrosMedicos?: boolean | Usuario$registrosMedicosArgs<ExtArgs>
    hogaresTemporales?: boolean | Usuario$hogaresTemporalesArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    telefono?: boolean
    tipoUsuario?: boolean
    estado?: boolean
    avatar?: boolean
    password?: boolean
    fechaRegistro?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    telefono?: boolean
    tipoUsuario?: boolean
    estado?: boolean
    avatar?: boolean
    password?: boolean
    fechaRegistro?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    email?: boolean
    telefono?: boolean
    tipoUsuario?: boolean
    estado?: boolean
    avatar?: boolean
    password?: boolean
    fechaRegistro?: boolean
  }

  export type UsuarioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "apellido" | "email" | "telefono" | "tipoUsuario" | "estado" | "avatar" | "password" | "fechaRegistro", ExtArgs["result"]["usuario"]>
  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adopciones?: boolean | Usuario$adopcionesArgs<ExtArgs>
    donaciones?: boolean | Usuario$donacionesArgs<ExtArgs>
    voluntariados?: boolean | Usuario$voluntariadosArgs<ExtArgs>
    registrosMedicos?: boolean | Usuario$registrosMedicosArgs<ExtArgs>
    hogaresTemporales?: boolean | Usuario$hogaresTemporalesArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuarioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      adopciones: Prisma.$AdopcionPayload<ExtArgs>[]
      donaciones: Prisma.$DonacionPayload<ExtArgs>[]
      voluntariados: Prisma.$VoluntariadoPayload<ExtArgs>[]
      registrosMedicos: Prisma.$RegistroMedicoPayload<ExtArgs>[]
      hogaresTemporales: Prisma.$HogarTemporalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string | null
      email: string
      telefono: string | null
      tipoUsuario: string
      estado: string
      avatar: string | null
      password: string
      fechaRegistro: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuarioUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adopciones<T extends Usuario$adopcionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$adopcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    donaciones<T extends Usuario$donacionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$donacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voluntariados<T extends Usuario$voluntariadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$voluntariadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrosMedicos<T extends Usuario$registrosMedicosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$registrosMedicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hogaresTemporales<T extends Usuario$hogaresTemporalesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$hogaresTemporalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'Int'>
    readonly nombre: FieldRef<"Usuario", 'String'>
    readonly apellido: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly telefono: FieldRef<"Usuario", 'String'>
    readonly tipoUsuario: FieldRef<"Usuario", 'String'>
    readonly estado: FieldRef<"Usuario", 'String'>
    readonly avatar: FieldRef<"Usuario", 'String'>
    readonly password: FieldRef<"Usuario", 'String'>
    readonly fechaRegistro: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario updateManyAndReturn
   */
  export type UsuarioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuario.adopciones
   */
  export type Usuario$adopcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    where?: AdopcionWhereInput
    orderBy?: AdopcionOrderByWithRelationInput | AdopcionOrderByWithRelationInput[]
    cursor?: AdopcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdopcionScalarFieldEnum | AdopcionScalarFieldEnum[]
  }

  /**
   * Usuario.donaciones
   */
  export type Usuario$donacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    where?: DonacionWhereInput
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    cursor?: DonacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Usuario.voluntariados
   */
  export type Usuario$voluntariadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    where?: VoluntariadoWhereInput
    orderBy?: VoluntariadoOrderByWithRelationInput | VoluntariadoOrderByWithRelationInput[]
    cursor?: VoluntariadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoluntariadoScalarFieldEnum | VoluntariadoScalarFieldEnum[]
  }

  /**
   * Usuario.registrosMedicos
   */
  export type Usuario$registrosMedicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    where?: RegistroMedicoWhereInput
    orderBy?: RegistroMedicoOrderByWithRelationInput | RegistroMedicoOrderByWithRelationInput[]
    cursor?: RegistroMedicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistroMedicoScalarFieldEnum | RegistroMedicoScalarFieldEnum[]
  }

  /**
   * Usuario.hogaresTemporales
   */
  export type Usuario$hogaresTemporalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    where?: HogarTemporalWhereInput
    orderBy?: HogarTemporalOrderByWithRelationInput | HogarTemporalOrderByWithRelationInput[]
    cursor?: HogarTemporalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HogarTemporalScalarFieldEnum | HogarTemporalScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuario
     */
    omit?: UsuarioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Animal
   */

  export type AggregateAnimal = {
    _count: AnimalCountAggregateOutputType | null
    _avg: AnimalAvgAggregateOutputType | null
    _sum: AnimalSumAggregateOutputType | null
    _min: AnimalMinAggregateOutputType | null
    _max: AnimalMaxAggregateOutputType | null
  }

  export type AnimalAvgAggregateOutputType = {
    id: number | null
    edad: number | null
  }

  export type AnimalSumAggregateOutputType = {
    id: number | null
    edad: number | null
  }

  export type AnimalMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    especie: string | null
    raza: string | null
    edad: number | null
    estado: string | null
    fechaIngreso: Date | null
    descripcion: string | null
    foto: string | null
  }

  export type AnimalMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    especie: string | null
    raza: string | null
    edad: number | null
    estado: string | null
    fechaIngreso: Date | null
    descripcion: string | null
    foto: string | null
  }

  export type AnimalCountAggregateOutputType = {
    id: number
    nombre: number
    especie: number
    raza: number
    edad: number
    estado: number
    fechaIngreso: number
    descripcion: number
    foto: number
    _all: number
  }


  export type AnimalAvgAggregateInputType = {
    id?: true
    edad?: true
  }

  export type AnimalSumAggregateInputType = {
    id?: true
    edad?: true
  }

  export type AnimalMinAggregateInputType = {
    id?: true
    nombre?: true
    especie?: true
    raza?: true
    edad?: true
    estado?: true
    fechaIngreso?: true
    descripcion?: true
    foto?: true
  }

  export type AnimalMaxAggregateInputType = {
    id?: true
    nombre?: true
    especie?: true
    raza?: true
    edad?: true
    estado?: true
    fechaIngreso?: true
    descripcion?: true
    foto?: true
  }

  export type AnimalCountAggregateInputType = {
    id?: true
    nombre?: true
    especie?: true
    raza?: true
    edad?: true
    estado?: true
    fechaIngreso?: true
    descripcion?: true
    foto?: true
    _all?: true
  }

  export type AnimalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Animal to aggregate.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Animals
    **/
    _count?: true | AnimalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimalMaxAggregateInputType
  }

  export type GetAnimalAggregateType<T extends AnimalAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimal[P]>
      : GetScalarType<T[P], AggregateAnimal[P]>
  }




  export type AnimalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimalWhereInput
    orderBy?: AnimalOrderByWithAggregationInput | AnimalOrderByWithAggregationInput[]
    by: AnimalScalarFieldEnum[] | AnimalScalarFieldEnum
    having?: AnimalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimalCountAggregateInputType | true
    _avg?: AnimalAvgAggregateInputType
    _sum?: AnimalSumAggregateInputType
    _min?: AnimalMinAggregateInputType
    _max?: AnimalMaxAggregateInputType
  }

  export type AnimalGroupByOutputType = {
    id: number
    nombre: string
    especie: string
    raza: string | null
    edad: number | null
    estado: string
    fechaIngreso: Date
    descripcion: string | null
    foto: string | null
    _count: AnimalCountAggregateOutputType | null
    _avg: AnimalAvgAggregateOutputType | null
    _sum: AnimalSumAggregateOutputType | null
    _min: AnimalMinAggregateOutputType | null
    _max: AnimalMaxAggregateOutputType | null
  }

  type GetAnimalGroupByPayload<T extends AnimalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimalGroupByOutputType[P]>
            : GetScalarType<T[P], AnimalGroupByOutputType[P]>
        }
      >
    >


  export type AnimalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    especie?: boolean
    raza?: boolean
    edad?: boolean
    estado?: boolean
    fechaIngreso?: boolean
    descripcion?: boolean
    foto?: boolean
    adopciones?: boolean | Animal$adopcionesArgs<ExtArgs>
    historias?: boolean | Animal$historiasArgs<ExtArgs>
    registrosMedicos?: boolean | Animal$registrosMedicosArgs<ExtArgs>
    hogaresTemporales?: boolean | Animal$hogaresTemporalesArgs<ExtArgs>
    _count?: boolean | AnimalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["animal"]>

  export type AnimalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    especie?: boolean
    raza?: boolean
    edad?: boolean
    estado?: boolean
    fechaIngreso?: boolean
    descripcion?: boolean
    foto?: boolean
  }, ExtArgs["result"]["animal"]>

  export type AnimalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    especie?: boolean
    raza?: boolean
    edad?: boolean
    estado?: boolean
    fechaIngreso?: boolean
    descripcion?: boolean
    foto?: boolean
  }, ExtArgs["result"]["animal"]>

  export type AnimalSelectScalar = {
    id?: boolean
    nombre?: boolean
    especie?: boolean
    raza?: boolean
    edad?: boolean
    estado?: boolean
    fechaIngreso?: boolean
    descripcion?: boolean
    foto?: boolean
  }

  export type AnimalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "especie" | "raza" | "edad" | "estado" | "fechaIngreso" | "descripcion" | "foto", ExtArgs["result"]["animal"]>
  export type AnimalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adopciones?: boolean | Animal$adopcionesArgs<ExtArgs>
    historias?: boolean | Animal$historiasArgs<ExtArgs>
    registrosMedicos?: boolean | Animal$registrosMedicosArgs<ExtArgs>
    hogaresTemporales?: boolean | Animal$hogaresTemporalesArgs<ExtArgs>
    _count?: boolean | AnimalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnimalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AnimalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnimalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Animal"
    objects: {
      adopciones: Prisma.$AdopcionPayload<ExtArgs>[]
      historias: Prisma.$HistoriaExitoPayload<ExtArgs>[]
      registrosMedicos: Prisma.$RegistroMedicoPayload<ExtArgs>[]
      hogaresTemporales: Prisma.$HogarTemporalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      especie: string
      raza: string | null
      edad: number | null
      estado: string
      fechaIngreso: Date
      descripcion: string | null
      foto: string | null
    }, ExtArgs["result"]["animal"]>
    composites: {}
  }

  type AnimalGetPayload<S extends boolean | null | undefined | AnimalDefaultArgs> = $Result.GetResult<Prisma.$AnimalPayload, S>

  type AnimalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnimalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnimalCountAggregateInputType | true
    }

  export interface AnimalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Animal'], meta: { name: 'Animal' } }
    /**
     * Find zero or one Animal that matches the filter.
     * @param {AnimalFindUniqueArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimalFindUniqueArgs>(args: SelectSubset<T, AnimalFindUniqueArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Animal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnimalFindUniqueOrThrowArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimalFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Animal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalFindFirstArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimalFindFirstArgs>(args?: SelectSubset<T, AnimalFindFirstArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Animal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalFindFirstOrThrowArgs} args - Arguments to find a Animal
     * @example
     * // Get one Animal
     * const animal = await prisma.animal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimalFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimalFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Animals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Animals
     * const animals = await prisma.animal.findMany()
     * 
     * // Get first 10 Animals
     * const animals = await prisma.animal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animalWithIdOnly = await prisma.animal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnimalFindManyArgs>(args?: SelectSubset<T, AnimalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Animal.
     * @param {AnimalCreateArgs} args - Arguments to create a Animal.
     * @example
     * // Create one Animal
     * const Animal = await prisma.animal.create({
     *   data: {
     *     // ... data to create a Animal
     *   }
     * })
     * 
     */
    create<T extends AnimalCreateArgs>(args: SelectSubset<T, AnimalCreateArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Animals.
     * @param {AnimalCreateManyArgs} args - Arguments to create many Animals.
     * @example
     * // Create many Animals
     * const animal = await prisma.animal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimalCreateManyArgs>(args?: SelectSubset<T, AnimalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Animals and returns the data saved in the database.
     * @param {AnimalCreateManyAndReturnArgs} args - Arguments to create many Animals.
     * @example
     * // Create many Animals
     * const animal = await prisma.animal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Animals and only return the `id`
     * const animalWithIdOnly = await prisma.animal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimalCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Animal.
     * @param {AnimalDeleteArgs} args - Arguments to delete one Animal.
     * @example
     * // Delete one Animal
     * const Animal = await prisma.animal.delete({
     *   where: {
     *     // ... filter to delete one Animal
     *   }
     * })
     * 
     */
    delete<T extends AnimalDeleteArgs>(args: SelectSubset<T, AnimalDeleteArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Animal.
     * @param {AnimalUpdateArgs} args - Arguments to update one Animal.
     * @example
     * // Update one Animal
     * const animal = await prisma.animal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimalUpdateArgs>(args: SelectSubset<T, AnimalUpdateArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Animals.
     * @param {AnimalDeleteManyArgs} args - Arguments to filter Animals to delete.
     * @example
     * // Delete a few Animals
     * const { count } = await prisma.animal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimalDeleteManyArgs>(args?: SelectSubset<T, AnimalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Animals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Animals
     * const animal = await prisma.animal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimalUpdateManyArgs>(args: SelectSubset<T, AnimalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Animals and returns the data updated in the database.
     * @param {AnimalUpdateManyAndReturnArgs} args - Arguments to update many Animals.
     * @example
     * // Update many Animals
     * const animal = await prisma.animal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Animals and only return the `id`
     * const animalWithIdOnly = await prisma.animal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnimalUpdateManyAndReturnArgs>(args: SelectSubset<T, AnimalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Animal.
     * @param {AnimalUpsertArgs} args - Arguments to update or create a Animal.
     * @example
     * // Update or create a Animal
     * const animal = await prisma.animal.upsert({
     *   create: {
     *     // ... data to create a Animal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Animal we want to update
     *   }
     * })
     */
    upsert<T extends AnimalUpsertArgs>(args: SelectSubset<T, AnimalUpsertArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Animals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalCountArgs} args - Arguments to filter Animals to count.
     * @example
     * // Count the number of Animals
     * const count = await prisma.animal.count({
     *   where: {
     *     // ... the filter for the Animals we want to count
     *   }
     * })
    **/
    count<T extends AnimalCountArgs>(
      args?: Subset<T, AnimalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Animal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimalAggregateArgs>(args: Subset<T, AnimalAggregateArgs>): Prisma.PrismaPromise<GetAnimalAggregateType<T>>

    /**
     * Group by Animal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimalGroupByArgs['orderBy'] }
        : { orderBy?: AnimalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Animal model
   */
  readonly fields: AnimalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Animal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adopciones<T extends Animal$adopcionesArgs<ExtArgs> = {}>(args?: Subset<T, Animal$adopcionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    historias<T extends Animal$historiasArgs<ExtArgs> = {}>(args?: Subset<T, Animal$historiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    registrosMedicos<T extends Animal$registrosMedicosArgs<ExtArgs> = {}>(args?: Subset<T, Animal$registrosMedicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hogaresTemporales<T extends Animal$hogaresTemporalesArgs<ExtArgs> = {}>(args?: Subset<T, Animal$hogaresTemporalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Animal model
   */
  interface AnimalFieldRefs {
    readonly id: FieldRef<"Animal", 'Int'>
    readonly nombre: FieldRef<"Animal", 'String'>
    readonly especie: FieldRef<"Animal", 'String'>
    readonly raza: FieldRef<"Animal", 'String'>
    readonly edad: FieldRef<"Animal", 'Int'>
    readonly estado: FieldRef<"Animal", 'String'>
    readonly fechaIngreso: FieldRef<"Animal", 'DateTime'>
    readonly descripcion: FieldRef<"Animal", 'String'>
    readonly foto: FieldRef<"Animal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Animal findUnique
   */
  export type AnimalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal findUniqueOrThrow
   */
  export type AnimalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal findFirst
   */
  export type AnimalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Animals.
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Animals.
     */
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Animal findFirstOrThrow
   */
  export type AnimalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animal to fetch.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Animals.
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Animals.
     */
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Animal findMany
   */
  export type AnimalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter, which Animals to fetch.
     */
    where?: AnimalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Animals to fetch.
     */
    orderBy?: AnimalOrderByWithRelationInput | AnimalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Animals.
     */
    cursor?: AnimalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Animals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Animals.
     */
    skip?: number
    distinct?: AnimalScalarFieldEnum | AnimalScalarFieldEnum[]
  }

  /**
   * Animal create
   */
  export type AnimalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * The data needed to create a Animal.
     */
    data: XOR<AnimalCreateInput, AnimalUncheckedCreateInput>
  }

  /**
   * Animal createMany
   */
  export type AnimalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Animals.
     */
    data: AnimalCreateManyInput | AnimalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Animal createManyAndReturn
   */
  export type AnimalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * The data used to create many Animals.
     */
    data: AnimalCreateManyInput | AnimalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Animal update
   */
  export type AnimalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * The data needed to update a Animal.
     */
    data: XOR<AnimalUpdateInput, AnimalUncheckedUpdateInput>
    /**
     * Choose, which Animal to update.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal updateMany
   */
  export type AnimalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Animals.
     */
    data: XOR<AnimalUpdateManyMutationInput, AnimalUncheckedUpdateManyInput>
    /**
     * Filter which Animals to update
     */
    where?: AnimalWhereInput
    /**
     * Limit how many Animals to update.
     */
    limit?: number
  }

  /**
   * Animal updateManyAndReturn
   */
  export type AnimalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * The data used to update Animals.
     */
    data: XOR<AnimalUpdateManyMutationInput, AnimalUncheckedUpdateManyInput>
    /**
     * Filter which Animals to update
     */
    where?: AnimalWhereInput
    /**
     * Limit how many Animals to update.
     */
    limit?: number
  }

  /**
   * Animal upsert
   */
  export type AnimalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * The filter to search for the Animal to update in case it exists.
     */
    where: AnimalWhereUniqueInput
    /**
     * In case the Animal found by the `where` argument doesn't exist, create a new Animal with this data.
     */
    create: XOR<AnimalCreateInput, AnimalUncheckedCreateInput>
    /**
     * In case the Animal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimalUpdateInput, AnimalUncheckedUpdateInput>
  }

  /**
   * Animal delete
   */
  export type AnimalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
    /**
     * Filter which Animal to delete.
     */
    where: AnimalWhereUniqueInput
  }

  /**
   * Animal deleteMany
   */
  export type AnimalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Animals to delete
     */
    where?: AnimalWhereInput
    /**
     * Limit how many Animals to delete.
     */
    limit?: number
  }

  /**
   * Animal.adopciones
   */
  export type Animal$adopcionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    where?: AdopcionWhereInput
    orderBy?: AdopcionOrderByWithRelationInput | AdopcionOrderByWithRelationInput[]
    cursor?: AdopcionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdopcionScalarFieldEnum | AdopcionScalarFieldEnum[]
  }

  /**
   * Animal.historias
   */
  export type Animal$historiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    where?: HistoriaExitoWhereInput
    orderBy?: HistoriaExitoOrderByWithRelationInput | HistoriaExitoOrderByWithRelationInput[]
    cursor?: HistoriaExitoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoriaExitoScalarFieldEnum | HistoriaExitoScalarFieldEnum[]
  }

  /**
   * Animal.registrosMedicos
   */
  export type Animal$registrosMedicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    where?: RegistroMedicoWhereInput
    orderBy?: RegistroMedicoOrderByWithRelationInput | RegistroMedicoOrderByWithRelationInput[]
    cursor?: RegistroMedicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistroMedicoScalarFieldEnum | RegistroMedicoScalarFieldEnum[]
  }

  /**
   * Animal.hogaresTemporales
   */
  export type Animal$hogaresTemporalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    where?: HogarTemporalWhereInput
    orderBy?: HogarTemporalOrderByWithRelationInput | HogarTemporalOrderByWithRelationInput[]
    cursor?: HogarTemporalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HogarTemporalScalarFieldEnum | HogarTemporalScalarFieldEnum[]
  }

  /**
   * Animal without action
   */
  export type AnimalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Animal
     */
    select?: AnimalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Animal
     */
    omit?: AnimalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimalInclude<ExtArgs> | null
  }


  /**
   * Model Adopcion
   */

  export type AggregateAdopcion = {
    _count: AdopcionCountAggregateOutputType | null
    _avg: AdopcionAvgAggregateOutputType | null
    _sum: AdopcionSumAggregateOutputType | null
    _min: AdopcionMinAggregateOutputType | null
    _max: AdopcionMaxAggregateOutputType | null
  }

  export type AdopcionAvgAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
  }

  export type AdopcionSumAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
  }

  export type AdopcionMinAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
    fechaAdopcion: Date | null
    estado: string | null
  }

  export type AdopcionMaxAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
    fechaAdopcion: Date | null
    estado: string | null
  }

  export type AdopcionCountAggregateOutputType = {
    id: number
    animalId: number
    usuarioId: number
    fechaAdopcion: number
    estado: number
    _all: number
  }


  export type AdopcionAvgAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
  }

  export type AdopcionSumAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
  }

  export type AdopcionMinAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
    fechaAdopcion?: true
    estado?: true
  }

  export type AdopcionMaxAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
    fechaAdopcion?: true
    estado?: true
  }

  export type AdopcionCountAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
    fechaAdopcion?: true
    estado?: true
    _all?: true
  }

  export type AdopcionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adopcion to aggregate.
     */
    where?: AdopcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adopcions to fetch.
     */
    orderBy?: AdopcionOrderByWithRelationInput | AdopcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdopcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adopcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adopcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Adopcions
    **/
    _count?: true | AdopcionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdopcionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdopcionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdopcionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdopcionMaxAggregateInputType
  }

  export type GetAdopcionAggregateType<T extends AdopcionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdopcion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdopcion[P]>
      : GetScalarType<T[P], AggregateAdopcion[P]>
  }




  export type AdopcionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdopcionWhereInput
    orderBy?: AdopcionOrderByWithAggregationInput | AdopcionOrderByWithAggregationInput[]
    by: AdopcionScalarFieldEnum[] | AdopcionScalarFieldEnum
    having?: AdopcionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdopcionCountAggregateInputType | true
    _avg?: AdopcionAvgAggregateInputType
    _sum?: AdopcionSumAggregateInputType
    _min?: AdopcionMinAggregateInputType
    _max?: AdopcionMaxAggregateInputType
  }

  export type AdopcionGroupByOutputType = {
    id: number
    animalId: number
    usuarioId: number
    fechaAdopcion: Date
    estado: string
    _count: AdopcionCountAggregateOutputType | null
    _avg: AdopcionAvgAggregateOutputType | null
    _sum: AdopcionSumAggregateOutputType | null
    _min: AdopcionMinAggregateOutputType | null
    _max: AdopcionMaxAggregateOutputType | null
  }

  type GetAdopcionGroupByPayload<T extends AdopcionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdopcionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdopcionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdopcionGroupByOutputType[P]>
            : GetScalarType<T[P], AdopcionGroupByOutputType[P]>
        }
      >
    >


  export type AdopcionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaAdopcion?: boolean
    estado?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adopcion"]>

  export type AdopcionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaAdopcion?: boolean
    estado?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adopcion"]>

  export type AdopcionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaAdopcion?: boolean
    estado?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adopcion"]>

  export type AdopcionSelectScalar = {
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaAdopcion?: boolean
    estado?: boolean
  }

  export type AdopcionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animalId" | "usuarioId" | "fechaAdopcion" | "estado", ExtArgs["result"]["adopcion"]>
  export type AdopcionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type AdopcionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type AdopcionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AdopcionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Adopcion"
    objects: {
      animal: Prisma.$AnimalPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      animalId: number
      usuarioId: number
      fechaAdopcion: Date
      estado: string
    }, ExtArgs["result"]["adopcion"]>
    composites: {}
  }

  type AdopcionGetPayload<S extends boolean | null | undefined | AdopcionDefaultArgs> = $Result.GetResult<Prisma.$AdopcionPayload, S>

  type AdopcionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdopcionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdopcionCountAggregateInputType | true
    }

  export interface AdopcionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Adopcion'], meta: { name: 'Adopcion' } }
    /**
     * Find zero or one Adopcion that matches the filter.
     * @param {AdopcionFindUniqueArgs} args - Arguments to find a Adopcion
     * @example
     * // Get one Adopcion
     * const adopcion = await prisma.adopcion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdopcionFindUniqueArgs>(args: SelectSubset<T, AdopcionFindUniqueArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Adopcion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdopcionFindUniqueOrThrowArgs} args - Arguments to find a Adopcion
     * @example
     * // Get one Adopcion
     * const adopcion = await prisma.adopcion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdopcionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdopcionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adopcion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionFindFirstArgs} args - Arguments to find a Adopcion
     * @example
     * // Get one Adopcion
     * const adopcion = await prisma.adopcion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdopcionFindFirstArgs>(args?: SelectSubset<T, AdopcionFindFirstArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Adopcion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionFindFirstOrThrowArgs} args - Arguments to find a Adopcion
     * @example
     * // Get one Adopcion
     * const adopcion = await prisma.adopcion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdopcionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdopcionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Adopcions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Adopcions
     * const adopcions = await prisma.adopcion.findMany()
     * 
     * // Get first 10 Adopcions
     * const adopcions = await prisma.adopcion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adopcionWithIdOnly = await prisma.adopcion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdopcionFindManyArgs>(args?: SelectSubset<T, AdopcionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Adopcion.
     * @param {AdopcionCreateArgs} args - Arguments to create a Adopcion.
     * @example
     * // Create one Adopcion
     * const Adopcion = await prisma.adopcion.create({
     *   data: {
     *     // ... data to create a Adopcion
     *   }
     * })
     * 
     */
    create<T extends AdopcionCreateArgs>(args: SelectSubset<T, AdopcionCreateArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Adopcions.
     * @param {AdopcionCreateManyArgs} args - Arguments to create many Adopcions.
     * @example
     * // Create many Adopcions
     * const adopcion = await prisma.adopcion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdopcionCreateManyArgs>(args?: SelectSubset<T, AdopcionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Adopcions and returns the data saved in the database.
     * @param {AdopcionCreateManyAndReturnArgs} args - Arguments to create many Adopcions.
     * @example
     * // Create many Adopcions
     * const adopcion = await prisma.adopcion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Adopcions and only return the `id`
     * const adopcionWithIdOnly = await prisma.adopcion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdopcionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdopcionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Adopcion.
     * @param {AdopcionDeleteArgs} args - Arguments to delete one Adopcion.
     * @example
     * // Delete one Adopcion
     * const Adopcion = await prisma.adopcion.delete({
     *   where: {
     *     // ... filter to delete one Adopcion
     *   }
     * })
     * 
     */
    delete<T extends AdopcionDeleteArgs>(args: SelectSubset<T, AdopcionDeleteArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Adopcion.
     * @param {AdopcionUpdateArgs} args - Arguments to update one Adopcion.
     * @example
     * // Update one Adopcion
     * const adopcion = await prisma.adopcion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdopcionUpdateArgs>(args: SelectSubset<T, AdopcionUpdateArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Adopcions.
     * @param {AdopcionDeleteManyArgs} args - Arguments to filter Adopcions to delete.
     * @example
     * // Delete a few Adopcions
     * const { count } = await prisma.adopcion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdopcionDeleteManyArgs>(args?: SelectSubset<T, AdopcionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adopcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Adopcions
     * const adopcion = await prisma.adopcion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdopcionUpdateManyArgs>(args: SelectSubset<T, AdopcionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Adopcions and returns the data updated in the database.
     * @param {AdopcionUpdateManyAndReturnArgs} args - Arguments to update many Adopcions.
     * @example
     * // Update many Adopcions
     * const adopcion = await prisma.adopcion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Adopcions and only return the `id`
     * const adopcionWithIdOnly = await prisma.adopcion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdopcionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdopcionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Adopcion.
     * @param {AdopcionUpsertArgs} args - Arguments to update or create a Adopcion.
     * @example
     * // Update or create a Adopcion
     * const adopcion = await prisma.adopcion.upsert({
     *   create: {
     *     // ... data to create a Adopcion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Adopcion we want to update
     *   }
     * })
     */
    upsert<T extends AdopcionUpsertArgs>(args: SelectSubset<T, AdopcionUpsertArgs<ExtArgs>>): Prisma__AdopcionClient<$Result.GetResult<Prisma.$AdopcionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Adopcions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionCountArgs} args - Arguments to filter Adopcions to count.
     * @example
     * // Count the number of Adopcions
     * const count = await prisma.adopcion.count({
     *   where: {
     *     // ... the filter for the Adopcions we want to count
     *   }
     * })
    **/
    count<T extends AdopcionCountArgs>(
      args?: Subset<T, AdopcionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdopcionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Adopcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdopcionAggregateArgs>(args: Subset<T, AdopcionAggregateArgs>): Prisma.PrismaPromise<GetAdopcionAggregateType<T>>

    /**
     * Group by Adopcion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdopcionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdopcionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdopcionGroupByArgs['orderBy'] }
        : { orderBy?: AdopcionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdopcionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdopcionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Adopcion model
   */
  readonly fields: AdopcionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Adopcion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdopcionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animal<T extends AnimalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimalDefaultArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Adopcion model
   */
  interface AdopcionFieldRefs {
    readonly id: FieldRef<"Adopcion", 'Int'>
    readonly animalId: FieldRef<"Adopcion", 'Int'>
    readonly usuarioId: FieldRef<"Adopcion", 'Int'>
    readonly fechaAdopcion: FieldRef<"Adopcion", 'DateTime'>
    readonly estado: FieldRef<"Adopcion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Adopcion findUnique
   */
  export type AdopcionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * Filter, which Adopcion to fetch.
     */
    where: AdopcionWhereUniqueInput
  }

  /**
   * Adopcion findUniqueOrThrow
   */
  export type AdopcionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * Filter, which Adopcion to fetch.
     */
    where: AdopcionWhereUniqueInput
  }

  /**
   * Adopcion findFirst
   */
  export type AdopcionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * Filter, which Adopcion to fetch.
     */
    where?: AdopcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adopcions to fetch.
     */
    orderBy?: AdopcionOrderByWithRelationInput | AdopcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adopcions.
     */
    cursor?: AdopcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adopcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adopcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adopcions.
     */
    distinct?: AdopcionScalarFieldEnum | AdopcionScalarFieldEnum[]
  }

  /**
   * Adopcion findFirstOrThrow
   */
  export type AdopcionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * Filter, which Adopcion to fetch.
     */
    where?: AdopcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adopcions to fetch.
     */
    orderBy?: AdopcionOrderByWithRelationInput | AdopcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Adopcions.
     */
    cursor?: AdopcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adopcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adopcions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Adopcions.
     */
    distinct?: AdopcionScalarFieldEnum | AdopcionScalarFieldEnum[]
  }

  /**
   * Adopcion findMany
   */
  export type AdopcionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * Filter, which Adopcions to fetch.
     */
    where?: AdopcionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Adopcions to fetch.
     */
    orderBy?: AdopcionOrderByWithRelationInput | AdopcionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Adopcions.
     */
    cursor?: AdopcionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Adopcions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Adopcions.
     */
    skip?: number
    distinct?: AdopcionScalarFieldEnum | AdopcionScalarFieldEnum[]
  }

  /**
   * Adopcion create
   */
  export type AdopcionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * The data needed to create a Adopcion.
     */
    data: XOR<AdopcionCreateInput, AdopcionUncheckedCreateInput>
  }

  /**
   * Adopcion createMany
   */
  export type AdopcionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Adopcions.
     */
    data: AdopcionCreateManyInput | AdopcionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Adopcion createManyAndReturn
   */
  export type AdopcionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * The data used to create many Adopcions.
     */
    data: AdopcionCreateManyInput | AdopcionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adopcion update
   */
  export type AdopcionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * The data needed to update a Adopcion.
     */
    data: XOR<AdopcionUpdateInput, AdopcionUncheckedUpdateInput>
    /**
     * Choose, which Adopcion to update.
     */
    where: AdopcionWhereUniqueInput
  }

  /**
   * Adopcion updateMany
   */
  export type AdopcionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Adopcions.
     */
    data: XOR<AdopcionUpdateManyMutationInput, AdopcionUncheckedUpdateManyInput>
    /**
     * Filter which Adopcions to update
     */
    where?: AdopcionWhereInput
    /**
     * Limit how many Adopcions to update.
     */
    limit?: number
  }

  /**
   * Adopcion updateManyAndReturn
   */
  export type AdopcionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * The data used to update Adopcions.
     */
    data: XOR<AdopcionUpdateManyMutationInput, AdopcionUncheckedUpdateManyInput>
    /**
     * Filter which Adopcions to update
     */
    where?: AdopcionWhereInput
    /**
     * Limit how many Adopcions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Adopcion upsert
   */
  export type AdopcionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * The filter to search for the Adopcion to update in case it exists.
     */
    where: AdopcionWhereUniqueInput
    /**
     * In case the Adopcion found by the `where` argument doesn't exist, create a new Adopcion with this data.
     */
    create: XOR<AdopcionCreateInput, AdopcionUncheckedCreateInput>
    /**
     * In case the Adopcion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdopcionUpdateInput, AdopcionUncheckedUpdateInput>
  }

  /**
   * Adopcion delete
   */
  export type AdopcionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
    /**
     * Filter which Adopcion to delete.
     */
    where: AdopcionWhereUniqueInput
  }

  /**
   * Adopcion deleteMany
   */
  export type AdopcionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Adopcions to delete
     */
    where?: AdopcionWhereInput
    /**
     * Limit how many Adopcions to delete.
     */
    limit?: number
  }

  /**
   * Adopcion without action
   */
  export type AdopcionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Adopcion
     */
    select?: AdopcionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Adopcion
     */
    omit?: AdopcionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdopcionInclude<ExtArgs> | null
  }


  /**
   * Model HistoriaExito
   */

  export type AggregateHistoriaExito = {
    _count: HistoriaExitoCountAggregateOutputType | null
    _avg: HistoriaExitoAvgAggregateOutputType | null
    _sum: HistoriaExitoSumAggregateOutputType | null
    _min: HistoriaExitoMinAggregateOutputType | null
    _max: HistoriaExitoMaxAggregateOutputType | null
  }

  export type HistoriaExitoAvgAggregateOutputType = {
    id: number | null
    animalId: number | null
  }

  export type HistoriaExitoSumAggregateOutputType = {
    id: number | null
    animalId: number | null
  }

  export type HistoriaExitoMinAggregateOutputType = {
    id: number | null
    animalId: number | null
    titulo: string | null
    descripcion: string | null
    fecha: Date | null
  }

  export type HistoriaExitoMaxAggregateOutputType = {
    id: number | null
    animalId: number | null
    titulo: string | null
    descripcion: string | null
    fecha: Date | null
  }

  export type HistoriaExitoCountAggregateOutputType = {
    id: number
    animalId: number
    titulo: number
    descripcion: number
    fecha: number
    _all: number
  }


  export type HistoriaExitoAvgAggregateInputType = {
    id?: true
    animalId?: true
  }

  export type HistoriaExitoSumAggregateInputType = {
    id?: true
    animalId?: true
  }

  export type HistoriaExitoMinAggregateInputType = {
    id?: true
    animalId?: true
    titulo?: true
    descripcion?: true
    fecha?: true
  }

  export type HistoriaExitoMaxAggregateInputType = {
    id?: true
    animalId?: true
    titulo?: true
    descripcion?: true
    fecha?: true
  }

  export type HistoriaExitoCountAggregateInputType = {
    id?: true
    animalId?: true
    titulo?: true
    descripcion?: true
    fecha?: true
    _all?: true
  }

  export type HistoriaExitoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoriaExito to aggregate.
     */
    where?: HistoriaExitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoriaExitos to fetch.
     */
    orderBy?: HistoriaExitoOrderByWithRelationInput | HistoriaExitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistoriaExitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoriaExitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoriaExitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistoriaExitos
    **/
    _count?: true | HistoriaExitoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoriaExitoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoriaExitoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoriaExitoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoriaExitoMaxAggregateInputType
  }

  export type GetHistoriaExitoAggregateType<T extends HistoriaExitoAggregateArgs> = {
        [P in keyof T & keyof AggregateHistoriaExito]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistoriaExito[P]>
      : GetScalarType<T[P], AggregateHistoriaExito[P]>
  }




  export type HistoriaExitoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistoriaExitoWhereInput
    orderBy?: HistoriaExitoOrderByWithAggregationInput | HistoriaExitoOrderByWithAggregationInput[]
    by: HistoriaExitoScalarFieldEnum[] | HistoriaExitoScalarFieldEnum
    having?: HistoriaExitoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoriaExitoCountAggregateInputType | true
    _avg?: HistoriaExitoAvgAggregateInputType
    _sum?: HistoriaExitoSumAggregateInputType
    _min?: HistoriaExitoMinAggregateInputType
    _max?: HistoriaExitoMaxAggregateInputType
  }

  export type HistoriaExitoGroupByOutputType = {
    id: number
    animalId: number
    titulo: string
    descripcion: string
    fecha: Date
    _count: HistoriaExitoCountAggregateOutputType | null
    _avg: HistoriaExitoAvgAggregateOutputType | null
    _sum: HistoriaExitoSumAggregateOutputType | null
    _min: HistoriaExitoMinAggregateOutputType | null
    _max: HistoriaExitoMaxAggregateOutputType | null
  }

  type GetHistoriaExitoGroupByPayload<T extends HistoriaExitoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoriaExitoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoriaExitoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoriaExitoGroupByOutputType[P]>
            : GetScalarType<T[P], HistoriaExitoGroupByOutputType[P]>
        }
      >
    >


  export type HistoriaExitoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    titulo?: boolean
    descripcion?: boolean
    fecha?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historiaExito"]>

  export type HistoriaExitoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    titulo?: boolean
    descripcion?: boolean
    fecha?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historiaExito"]>

  export type HistoriaExitoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    titulo?: boolean
    descripcion?: boolean
    fecha?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historiaExito"]>

  export type HistoriaExitoSelectScalar = {
    id?: boolean
    animalId?: boolean
    titulo?: boolean
    descripcion?: boolean
    fecha?: boolean
  }

  export type HistoriaExitoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animalId" | "titulo" | "descripcion" | "fecha", ExtArgs["result"]["historiaExito"]>
  export type HistoriaExitoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
  }
  export type HistoriaExitoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
  }
  export type HistoriaExitoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
  }

  export type $HistoriaExitoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistoriaExito"
    objects: {
      animal: Prisma.$AnimalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      animalId: number
      titulo: string
      descripcion: string
      fecha: Date
    }, ExtArgs["result"]["historiaExito"]>
    composites: {}
  }

  type HistoriaExitoGetPayload<S extends boolean | null | undefined | HistoriaExitoDefaultArgs> = $Result.GetResult<Prisma.$HistoriaExitoPayload, S>

  type HistoriaExitoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HistoriaExitoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoriaExitoCountAggregateInputType | true
    }

  export interface HistoriaExitoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistoriaExito'], meta: { name: 'HistoriaExito' } }
    /**
     * Find zero or one HistoriaExito that matches the filter.
     * @param {HistoriaExitoFindUniqueArgs} args - Arguments to find a HistoriaExito
     * @example
     * // Get one HistoriaExito
     * const historiaExito = await prisma.historiaExito.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistoriaExitoFindUniqueArgs>(args: SelectSubset<T, HistoriaExitoFindUniqueArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HistoriaExito that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HistoriaExitoFindUniqueOrThrowArgs} args - Arguments to find a HistoriaExito
     * @example
     * // Get one HistoriaExito
     * const historiaExito = await prisma.historiaExito.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistoriaExitoFindUniqueOrThrowArgs>(args: SelectSubset<T, HistoriaExitoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoriaExito that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoFindFirstArgs} args - Arguments to find a HistoriaExito
     * @example
     * // Get one HistoriaExito
     * const historiaExito = await prisma.historiaExito.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistoriaExitoFindFirstArgs>(args?: SelectSubset<T, HistoriaExitoFindFirstArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HistoriaExito that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoFindFirstOrThrowArgs} args - Arguments to find a HistoriaExito
     * @example
     * // Get one HistoriaExito
     * const historiaExito = await prisma.historiaExito.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistoriaExitoFindFirstOrThrowArgs>(args?: SelectSubset<T, HistoriaExitoFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HistoriaExitos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistoriaExitos
     * const historiaExitos = await prisma.historiaExito.findMany()
     * 
     * // Get first 10 HistoriaExitos
     * const historiaExitos = await prisma.historiaExito.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historiaExitoWithIdOnly = await prisma.historiaExito.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistoriaExitoFindManyArgs>(args?: SelectSubset<T, HistoriaExitoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HistoriaExito.
     * @param {HistoriaExitoCreateArgs} args - Arguments to create a HistoriaExito.
     * @example
     * // Create one HistoriaExito
     * const HistoriaExito = await prisma.historiaExito.create({
     *   data: {
     *     // ... data to create a HistoriaExito
     *   }
     * })
     * 
     */
    create<T extends HistoriaExitoCreateArgs>(args: SelectSubset<T, HistoriaExitoCreateArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HistoriaExitos.
     * @param {HistoriaExitoCreateManyArgs} args - Arguments to create many HistoriaExitos.
     * @example
     * // Create many HistoriaExitos
     * const historiaExito = await prisma.historiaExito.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistoriaExitoCreateManyArgs>(args?: SelectSubset<T, HistoriaExitoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistoriaExitos and returns the data saved in the database.
     * @param {HistoriaExitoCreateManyAndReturnArgs} args - Arguments to create many HistoriaExitos.
     * @example
     * // Create many HistoriaExitos
     * const historiaExito = await prisma.historiaExito.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistoriaExitos and only return the `id`
     * const historiaExitoWithIdOnly = await prisma.historiaExito.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistoriaExitoCreateManyAndReturnArgs>(args?: SelectSubset<T, HistoriaExitoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HistoriaExito.
     * @param {HistoriaExitoDeleteArgs} args - Arguments to delete one HistoriaExito.
     * @example
     * // Delete one HistoriaExito
     * const HistoriaExito = await prisma.historiaExito.delete({
     *   where: {
     *     // ... filter to delete one HistoriaExito
     *   }
     * })
     * 
     */
    delete<T extends HistoriaExitoDeleteArgs>(args: SelectSubset<T, HistoriaExitoDeleteArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HistoriaExito.
     * @param {HistoriaExitoUpdateArgs} args - Arguments to update one HistoriaExito.
     * @example
     * // Update one HistoriaExito
     * const historiaExito = await prisma.historiaExito.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistoriaExitoUpdateArgs>(args: SelectSubset<T, HistoriaExitoUpdateArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HistoriaExitos.
     * @param {HistoriaExitoDeleteManyArgs} args - Arguments to filter HistoriaExitos to delete.
     * @example
     * // Delete a few HistoriaExitos
     * const { count } = await prisma.historiaExito.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistoriaExitoDeleteManyArgs>(args?: SelectSubset<T, HistoriaExitoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoriaExitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistoriaExitos
     * const historiaExito = await prisma.historiaExito.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistoriaExitoUpdateManyArgs>(args: SelectSubset<T, HistoriaExitoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistoriaExitos and returns the data updated in the database.
     * @param {HistoriaExitoUpdateManyAndReturnArgs} args - Arguments to update many HistoriaExitos.
     * @example
     * // Update many HistoriaExitos
     * const historiaExito = await prisma.historiaExito.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HistoriaExitos and only return the `id`
     * const historiaExitoWithIdOnly = await prisma.historiaExito.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HistoriaExitoUpdateManyAndReturnArgs>(args: SelectSubset<T, HistoriaExitoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HistoriaExito.
     * @param {HistoriaExitoUpsertArgs} args - Arguments to update or create a HistoriaExito.
     * @example
     * // Update or create a HistoriaExito
     * const historiaExito = await prisma.historiaExito.upsert({
     *   create: {
     *     // ... data to create a HistoriaExito
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistoriaExito we want to update
     *   }
     * })
     */
    upsert<T extends HistoriaExitoUpsertArgs>(args: SelectSubset<T, HistoriaExitoUpsertArgs<ExtArgs>>): Prisma__HistoriaExitoClient<$Result.GetResult<Prisma.$HistoriaExitoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HistoriaExitos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoCountArgs} args - Arguments to filter HistoriaExitos to count.
     * @example
     * // Count the number of HistoriaExitos
     * const count = await prisma.historiaExito.count({
     *   where: {
     *     // ... the filter for the HistoriaExitos we want to count
     *   }
     * })
    **/
    count<T extends HistoriaExitoCountArgs>(
      args?: Subset<T, HistoriaExitoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoriaExitoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistoriaExito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoriaExitoAggregateArgs>(args: Subset<T, HistoriaExitoAggregateArgs>): Prisma.PrismaPromise<GetHistoriaExitoAggregateType<T>>

    /**
     * Group by HistoriaExito.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriaExitoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistoriaExitoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistoriaExitoGroupByArgs['orderBy'] }
        : { orderBy?: HistoriaExitoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistoriaExitoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoriaExitoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistoriaExito model
   */
  readonly fields: HistoriaExitoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistoriaExito.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistoriaExitoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animal<T extends AnimalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimalDefaultArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistoriaExito model
   */
  interface HistoriaExitoFieldRefs {
    readonly id: FieldRef<"HistoriaExito", 'Int'>
    readonly animalId: FieldRef<"HistoriaExito", 'Int'>
    readonly titulo: FieldRef<"HistoriaExito", 'String'>
    readonly descripcion: FieldRef<"HistoriaExito", 'String'>
    readonly fecha: FieldRef<"HistoriaExito", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HistoriaExito findUnique
   */
  export type HistoriaExitoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * Filter, which HistoriaExito to fetch.
     */
    where: HistoriaExitoWhereUniqueInput
  }

  /**
   * HistoriaExito findUniqueOrThrow
   */
  export type HistoriaExitoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * Filter, which HistoriaExito to fetch.
     */
    where: HistoriaExitoWhereUniqueInput
  }

  /**
   * HistoriaExito findFirst
   */
  export type HistoriaExitoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * Filter, which HistoriaExito to fetch.
     */
    where?: HistoriaExitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoriaExitos to fetch.
     */
    orderBy?: HistoriaExitoOrderByWithRelationInput | HistoriaExitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoriaExitos.
     */
    cursor?: HistoriaExitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoriaExitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoriaExitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoriaExitos.
     */
    distinct?: HistoriaExitoScalarFieldEnum | HistoriaExitoScalarFieldEnum[]
  }

  /**
   * HistoriaExito findFirstOrThrow
   */
  export type HistoriaExitoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * Filter, which HistoriaExito to fetch.
     */
    where?: HistoriaExitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoriaExitos to fetch.
     */
    orderBy?: HistoriaExitoOrderByWithRelationInput | HistoriaExitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistoriaExitos.
     */
    cursor?: HistoriaExitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoriaExitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoriaExitos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistoriaExitos.
     */
    distinct?: HistoriaExitoScalarFieldEnum | HistoriaExitoScalarFieldEnum[]
  }

  /**
   * HistoriaExito findMany
   */
  export type HistoriaExitoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * Filter, which HistoriaExitos to fetch.
     */
    where?: HistoriaExitoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistoriaExitos to fetch.
     */
    orderBy?: HistoriaExitoOrderByWithRelationInput | HistoriaExitoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistoriaExitos.
     */
    cursor?: HistoriaExitoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistoriaExitos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistoriaExitos.
     */
    skip?: number
    distinct?: HistoriaExitoScalarFieldEnum | HistoriaExitoScalarFieldEnum[]
  }

  /**
   * HistoriaExito create
   */
  export type HistoriaExitoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * The data needed to create a HistoriaExito.
     */
    data: XOR<HistoriaExitoCreateInput, HistoriaExitoUncheckedCreateInput>
  }

  /**
   * HistoriaExito createMany
   */
  export type HistoriaExitoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistoriaExitos.
     */
    data: HistoriaExitoCreateManyInput | HistoriaExitoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistoriaExito createManyAndReturn
   */
  export type HistoriaExitoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * The data used to create many HistoriaExitos.
     */
    data: HistoriaExitoCreateManyInput | HistoriaExitoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HistoriaExito update
   */
  export type HistoriaExitoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * The data needed to update a HistoriaExito.
     */
    data: XOR<HistoriaExitoUpdateInput, HistoriaExitoUncheckedUpdateInput>
    /**
     * Choose, which HistoriaExito to update.
     */
    where: HistoriaExitoWhereUniqueInput
  }

  /**
   * HistoriaExito updateMany
   */
  export type HistoriaExitoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistoriaExitos.
     */
    data: XOR<HistoriaExitoUpdateManyMutationInput, HistoriaExitoUncheckedUpdateManyInput>
    /**
     * Filter which HistoriaExitos to update
     */
    where?: HistoriaExitoWhereInput
    /**
     * Limit how many HistoriaExitos to update.
     */
    limit?: number
  }

  /**
   * HistoriaExito updateManyAndReturn
   */
  export type HistoriaExitoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * The data used to update HistoriaExitos.
     */
    data: XOR<HistoriaExitoUpdateManyMutationInput, HistoriaExitoUncheckedUpdateManyInput>
    /**
     * Filter which HistoriaExitos to update
     */
    where?: HistoriaExitoWhereInput
    /**
     * Limit how many HistoriaExitos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HistoriaExito upsert
   */
  export type HistoriaExitoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * The filter to search for the HistoriaExito to update in case it exists.
     */
    where: HistoriaExitoWhereUniqueInput
    /**
     * In case the HistoriaExito found by the `where` argument doesn't exist, create a new HistoriaExito with this data.
     */
    create: XOR<HistoriaExitoCreateInput, HistoriaExitoUncheckedCreateInput>
    /**
     * In case the HistoriaExito was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistoriaExitoUpdateInput, HistoriaExitoUncheckedUpdateInput>
  }

  /**
   * HistoriaExito delete
   */
  export type HistoriaExitoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
    /**
     * Filter which HistoriaExito to delete.
     */
    where: HistoriaExitoWhereUniqueInput
  }

  /**
   * HistoriaExito deleteMany
   */
  export type HistoriaExitoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistoriaExitos to delete
     */
    where?: HistoriaExitoWhereInput
    /**
     * Limit how many HistoriaExitos to delete.
     */
    limit?: number
  }

  /**
   * HistoriaExito without action
   */
  export type HistoriaExitoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistoriaExito
     */
    select?: HistoriaExitoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HistoriaExito
     */
    omit?: HistoriaExitoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistoriaExitoInclude<ExtArgs> | null
  }


  /**
   * Model Donacion
   */

  export type AggregateDonacion = {
    _count: DonacionCountAggregateOutputType | null
    _avg: DonacionAvgAggregateOutputType | null
    _sum: DonacionSumAggregateOutputType | null
    _min: DonacionMinAggregateOutputType | null
    _max: DonacionMaxAggregateOutputType | null
  }

  export type DonacionAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    monto: number | null
  }

  export type DonacionSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    monto: number | null
  }

  export type DonacionMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    monto: number | null
    fecha: Date | null
    tipo: string | null
  }

  export type DonacionMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    monto: number | null
    fecha: Date | null
    tipo: string | null
  }

  export type DonacionCountAggregateOutputType = {
    id: number
    usuarioId: number
    monto: number
    fecha: number
    tipo: number
    _all: number
  }


  export type DonacionAvgAggregateInputType = {
    id?: true
    usuarioId?: true
    monto?: true
  }

  export type DonacionSumAggregateInputType = {
    id?: true
    usuarioId?: true
    monto?: true
  }

  export type DonacionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    monto?: true
    fecha?: true
    tipo?: true
  }

  export type DonacionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    monto?: true
    fecha?: true
    tipo?: true
  }

  export type DonacionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    monto?: true
    fecha?: true
    tipo?: true
    _all?: true
  }

  export type DonacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donacion to aggregate.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donacions
    **/
    _count?: true | DonacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonacionMaxAggregateInputType
  }

  export type GetDonacionAggregateType<T extends DonacionAggregateArgs> = {
        [P in keyof T & keyof AggregateDonacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonacion[P]>
      : GetScalarType<T[P], AggregateDonacion[P]>
  }




  export type DonacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DonacionWhereInput
    orderBy?: DonacionOrderByWithAggregationInput | DonacionOrderByWithAggregationInput[]
    by: DonacionScalarFieldEnum[] | DonacionScalarFieldEnum
    having?: DonacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonacionCountAggregateInputType | true
    _avg?: DonacionAvgAggregateInputType
    _sum?: DonacionSumAggregateInputType
    _min?: DonacionMinAggregateInputType
    _max?: DonacionMaxAggregateInputType
  }

  export type DonacionGroupByOutputType = {
    id: number
    usuarioId: number
    monto: number
    fecha: Date
    tipo: string
    _count: DonacionCountAggregateOutputType | null
    _avg: DonacionAvgAggregateOutputType | null
    _sum: DonacionSumAggregateOutputType | null
    _min: DonacionMinAggregateOutputType | null
    _max: DonacionMaxAggregateOutputType | null
  }

  type GetDonacionGroupByPayload<T extends DonacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonacionGroupByOutputType[P]>
            : GetScalarType<T[P], DonacionGroupByOutputType[P]>
        }
      >
    >


  export type DonacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    monto?: boolean
    fecha?: boolean
    tipo?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donacion"]>

  export type DonacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    monto?: boolean
    fecha?: boolean
    tipo?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donacion"]>

  export type DonacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    monto?: boolean
    fecha?: boolean
    tipo?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donacion"]>

  export type DonacionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    monto?: boolean
    fecha?: boolean
    tipo?: boolean
  }

  export type DonacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "monto" | "fecha" | "tipo", ExtArgs["result"]["donacion"]>
  export type DonacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type DonacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type DonacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $DonacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Donacion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      monto: number
      fecha: Date
      tipo: string
    }, ExtArgs["result"]["donacion"]>
    composites: {}
  }

  type DonacionGetPayload<S extends boolean | null | undefined | DonacionDefaultArgs> = $Result.GetResult<Prisma.$DonacionPayload, S>

  type DonacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DonacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DonacionCountAggregateInputType | true
    }

  export interface DonacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donacion'], meta: { name: 'Donacion' } }
    /**
     * Find zero or one Donacion that matches the filter.
     * @param {DonacionFindUniqueArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DonacionFindUniqueArgs>(args: SelectSubset<T, DonacionFindUniqueArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Donacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DonacionFindUniqueOrThrowArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DonacionFindUniqueOrThrowArgs>(args: SelectSubset<T, DonacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionFindFirstArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DonacionFindFirstArgs>(args?: SelectSubset<T, DonacionFindFirstArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Donacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionFindFirstOrThrowArgs} args - Arguments to find a Donacion
     * @example
     * // Get one Donacion
     * const donacion = await prisma.donacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DonacionFindFirstOrThrowArgs>(args?: SelectSubset<T, DonacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Donacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donacions
     * const donacions = await prisma.donacion.findMany()
     * 
     * // Get first 10 Donacions
     * const donacions = await prisma.donacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donacionWithIdOnly = await prisma.donacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DonacionFindManyArgs>(args?: SelectSubset<T, DonacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Donacion.
     * @param {DonacionCreateArgs} args - Arguments to create a Donacion.
     * @example
     * // Create one Donacion
     * const Donacion = await prisma.donacion.create({
     *   data: {
     *     // ... data to create a Donacion
     *   }
     * })
     * 
     */
    create<T extends DonacionCreateArgs>(args: SelectSubset<T, DonacionCreateArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Donacions.
     * @param {DonacionCreateManyArgs} args - Arguments to create many Donacions.
     * @example
     * // Create many Donacions
     * const donacion = await prisma.donacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DonacionCreateManyArgs>(args?: SelectSubset<T, DonacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Donacions and returns the data saved in the database.
     * @param {DonacionCreateManyAndReturnArgs} args - Arguments to create many Donacions.
     * @example
     * // Create many Donacions
     * const donacion = await prisma.donacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Donacions and only return the `id`
     * const donacionWithIdOnly = await prisma.donacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DonacionCreateManyAndReturnArgs>(args?: SelectSubset<T, DonacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Donacion.
     * @param {DonacionDeleteArgs} args - Arguments to delete one Donacion.
     * @example
     * // Delete one Donacion
     * const Donacion = await prisma.donacion.delete({
     *   where: {
     *     // ... filter to delete one Donacion
     *   }
     * })
     * 
     */
    delete<T extends DonacionDeleteArgs>(args: SelectSubset<T, DonacionDeleteArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Donacion.
     * @param {DonacionUpdateArgs} args - Arguments to update one Donacion.
     * @example
     * // Update one Donacion
     * const donacion = await prisma.donacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DonacionUpdateArgs>(args: SelectSubset<T, DonacionUpdateArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Donacions.
     * @param {DonacionDeleteManyArgs} args - Arguments to filter Donacions to delete.
     * @example
     * // Delete a few Donacions
     * const { count } = await prisma.donacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DonacionDeleteManyArgs>(args?: SelectSubset<T, DonacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donacions
     * const donacion = await prisma.donacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DonacionUpdateManyArgs>(args: SelectSubset<T, DonacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donacions and returns the data updated in the database.
     * @param {DonacionUpdateManyAndReturnArgs} args - Arguments to update many Donacions.
     * @example
     * // Update many Donacions
     * const donacion = await prisma.donacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Donacions and only return the `id`
     * const donacionWithIdOnly = await prisma.donacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DonacionUpdateManyAndReturnArgs>(args: SelectSubset<T, DonacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Donacion.
     * @param {DonacionUpsertArgs} args - Arguments to update or create a Donacion.
     * @example
     * // Update or create a Donacion
     * const donacion = await prisma.donacion.upsert({
     *   create: {
     *     // ... data to create a Donacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donacion we want to update
     *   }
     * })
     */
    upsert<T extends DonacionUpsertArgs>(args: SelectSubset<T, DonacionUpsertArgs<ExtArgs>>): Prisma__DonacionClient<$Result.GetResult<Prisma.$DonacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Donacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionCountArgs} args - Arguments to filter Donacions to count.
     * @example
     * // Count the number of Donacions
     * const count = await prisma.donacion.count({
     *   where: {
     *     // ... the filter for the Donacions we want to count
     *   }
     * })
    **/
    count<T extends DonacionCountArgs>(
      args?: Subset<T, DonacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonacionAggregateArgs>(args: Subset<T, DonacionAggregateArgs>): Prisma.PrismaPromise<GetDonacionAggregateType<T>>

    /**
     * Group by Donacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonacionGroupByArgs['orderBy'] }
        : { orderBy?: DonacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donacion model
   */
  readonly fields: DonacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Donacion model
   */
  interface DonacionFieldRefs {
    readonly id: FieldRef<"Donacion", 'Int'>
    readonly usuarioId: FieldRef<"Donacion", 'Int'>
    readonly monto: FieldRef<"Donacion", 'Float'>
    readonly fecha: FieldRef<"Donacion", 'DateTime'>
    readonly tipo: FieldRef<"Donacion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Donacion findUnique
   */
  export type DonacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion findUniqueOrThrow
   */
  export type DonacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion findFirst
   */
  export type DonacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donacions.
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donacions.
     */
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donacion findFirstOrThrow
   */
  export type DonacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacion to fetch.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donacions.
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donacions.
     */
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donacion findMany
   */
  export type DonacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter, which Donacions to fetch.
     */
    where?: DonacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donacions to fetch.
     */
    orderBy?: DonacionOrderByWithRelationInput | DonacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donacions.
     */
    cursor?: DonacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donacions.
     */
    skip?: number
    distinct?: DonacionScalarFieldEnum | DonacionScalarFieldEnum[]
  }

  /**
   * Donacion create
   */
  export type DonacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Donacion.
     */
    data: XOR<DonacionCreateInput, DonacionUncheckedCreateInput>
  }

  /**
   * Donacion createMany
   */
  export type DonacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donacions.
     */
    data: DonacionCreateManyInput | DonacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Donacion createManyAndReturn
   */
  export type DonacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * The data used to create many Donacions.
     */
    data: DonacionCreateManyInput | DonacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donacion update
   */
  export type DonacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Donacion.
     */
    data: XOR<DonacionUpdateInput, DonacionUncheckedUpdateInput>
    /**
     * Choose, which Donacion to update.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion updateMany
   */
  export type DonacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donacions.
     */
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyInput>
    /**
     * Filter which Donacions to update
     */
    where?: DonacionWhereInput
    /**
     * Limit how many Donacions to update.
     */
    limit?: number
  }

  /**
   * Donacion updateManyAndReturn
   */
  export type DonacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * The data used to update Donacions.
     */
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyInput>
    /**
     * Filter which Donacions to update
     */
    where?: DonacionWhereInput
    /**
     * Limit how many Donacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Donacion upsert
   */
  export type DonacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Donacion to update in case it exists.
     */
    where: DonacionWhereUniqueInput
    /**
     * In case the Donacion found by the `where` argument doesn't exist, create a new Donacion with this data.
     */
    create: XOR<DonacionCreateInput, DonacionUncheckedCreateInput>
    /**
     * In case the Donacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonacionUpdateInput, DonacionUncheckedUpdateInput>
  }

  /**
   * Donacion delete
   */
  export type DonacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
    /**
     * Filter which Donacion to delete.
     */
    where: DonacionWhereUniqueInput
  }

  /**
   * Donacion deleteMany
   */
  export type DonacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donacions to delete
     */
    where?: DonacionWhereInput
    /**
     * Limit how many Donacions to delete.
     */
    limit?: number
  }

  /**
   * Donacion without action
   */
  export type DonacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donacion
     */
    select?: DonacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Donacion
     */
    omit?: DonacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DonacionInclude<ExtArgs> | null
  }


  /**
   * Model RegistroMedico
   */

  export type AggregateRegistroMedico = {
    _count: RegistroMedicoCountAggregateOutputType | null
    _avg: RegistroMedicoAvgAggregateOutputType | null
    _sum: RegistroMedicoSumAggregateOutputType | null
    _min: RegistroMedicoMinAggregateOutputType | null
    _max: RegistroMedicoMaxAggregateOutputType | null
  }

  export type RegistroMedicoAvgAggregateOutputType = {
    id: number | null
    animalId: number | null
    veterinarioId: number | null
  }

  export type RegistroMedicoSumAggregateOutputType = {
    id: number | null
    animalId: number | null
    veterinarioId: number | null
  }

  export type RegistroMedicoMinAggregateOutputType = {
    id: number | null
    animalId: number | null
    veterinarioId: number | null
    descripcion: string | null
    fecha: Date | null
    tipo: string | null
  }

  export type RegistroMedicoMaxAggregateOutputType = {
    id: number | null
    animalId: number | null
    veterinarioId: number | null
    descripcion: string | null
    fecha: Date | null
    tipo: string | null
  }

  export type RegistroMedicoCountAggregateOutputType = {
    id: number
    animalId: number
    veterinarioId: number
    descripcion: number
    fecha: number
    tipo: number
    _all: number
  }


  export type RegistroMedicoAvgAggregateInputType = {
    id?: true
    animalId?: true
    veterinarioId?: true
  }

  export type RegistroMedicoSumAggregateInputType = {
    id?: true
    animalId?: true
    veterinarioId?: true
  }

  export type RegistroMedicoMinAggregateInputType = {
    id?: true
    animalId?: true
    veterinarioId?: true
    descripcion?: true
    fecha?: true
    tipo?: true
  }

  export type RegistroMedicoMaxAggregateInputType = {
    id?: true
    animalId?: true
    veterinarioId?: true
    descripcion?: true
    fecha?: true
    tipo?: true
  }

  export type RegistroMedicoCountAggregateInputType = {
    id?: true
    animalId?: true
    veterinarioId?: true
    descripcion?: true
    fecha?: true
    tipo?: true
    _all?: true
  }

  export type RegistroMedicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroMedico to aggregate.
     */
    where?: RegistroMedicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroMedicos to fetch.
     */
    orderBy?: RegistroMedicoOrderByWithRelationInput | RegistroMedicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegistroMedicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroMedicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroMedicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegistroMedicos
    **/
    _count?: true | RegistroMedicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegistroMedicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegistroMedicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistroMedicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistroMedicoMaxAggregateInputType
  }

  export type GetRegistroMedicoAggregateType<T extends RegistroMedicoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistroMedico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistroMedico[P]>
      : GetScalarType<T[P], AggregateRegistroMedico[P]>
  }




  export type RegistroMedicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroMedicoWhereInput
    orderBy?: RegistroMedicoOrderByWithAggregationInput | RegistroMedicoOrderByWithAggregationInput[]
    by: RegistroMedicoScalarFieldEnum[] | RegistroMedicoScalarFieldEnum
    having?: RegistroMedicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistroMedicoCountAggregateInputType | true
    _avg?: RegistroMedicoAvgAggregateInputType
    _sum?: RegistroMedicoSumAggregateInputType
    _min?: RegistroMedicoMinAggregateInputType
    _max?: RegistroMedicoMaxAggregateInputType
  }

  export type RegistroMedicoGroupByOutputType = {
    id: number
    animalId: number
    veterinarioId: number
    descripcion: string
    fecha: Date
    tipo: string
    _count: RegistroMedicoCountAggregateOutputType | null
    _avg: RegistroMedicoAvgAggregateOutputType | null
    _sum: RegistroMedicoSumAggregateOutputType | null
    _min: RegistroMedicoMinAggregateOutputType | null
    _max: RegistroMedicoMaxAggregateOutputType | null
  }

  type GetRegistroMedicoGroupByPayload<T extends RegistroMedicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistroMedicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistroMedicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistroMedicoGroupByOutputType[P]>
            : GetScalarType<T[P], RegistroMedicoGroupByOutputType[P]>
        }
      >
    >


  export type RegistroMedicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    veterinarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    tipo?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    veterinario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroMedico"]>

  export type RegistroMedicoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    veterinarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    tipo?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    veterinario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroMedico"]>

  export type RegistroMedicoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    veterinarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    tipo?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    veterinario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroMedico"]>

  export type RegistroMedicoSelectScalar = {
    id?: boolean
    animalId?: boolean
    veterinarioId?: boolean
    descripcion?: boolean
    fecha?: boolean
    tipo?: boolean
  }

  export type RegistroMedicoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animalId" | "veterinarioId" | "descripcion" | "fecha" | "tipo", ExtArgs["result"]["registroMedico"]>
  export type RegistroMedicoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    veterinario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RegistroMedicoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    veterinario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type RegistroMedicoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    veterinario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $RegistroMedicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegistroMedico"
    objects: {
      animal: Prisma.$AnimalPayload<ExtArgs>
      veterinario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      animalId: number
      veterinarioId: number
      descripcion: string
      fecha: Date
      tipo: string
    }, ExtArgs["result"]["registroMedico"]>
    composites: {}
  }

  type RegistroMedicoGetPayload<S extends boolean | null | undefined | RegistroMedicoDefaultArgs> = $Result.GetResult<Prisma.$RegistroMedicoPayload, S>

  type RegistroMedicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegistroMedicoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegistroMedicoCountAggregateInputType | true
    }

  export interface RegistroMedicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegistroMedico'], meta: { name: 'RegistroMedico' } }
    /**
     * Find zero or one RegistroMedico that matches the filter.
     * @param {RegistroMedicoFindUniqueArgs} args - Arguments to find a RegistroMedico
     * @example
     * // Get one RegistroMedico
     * const registroMedico = await prisma.registroMedico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegistroMedicoFindUniqueArgs>(args: SelectSubset<T, RegistroMedicoFindUniqueArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegistroMedico that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegistroMedicoFindUniqueOrThrowArgs} args - Arguments to find a RegistroMedico
     * @example
     * // Get one RegistroMedico
     * const registroMedico = await prisma.registroMedico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegistroMedicoFindUniqueOrThrowArgs>(args: SelectSubset<T, RegistroMedicoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegistroMedico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoFindFirstArgs} args - Arguments to find a RegistroMedico
     * @example
     * // Get one RegistroMedico
     * const registroMedico = await prisma.registroMedico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegistroMedicoFindFirstArgs>(args?: SelectSubset<T, RegistroMedicoFindFirstArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegistroMedico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoFindFirstOrThrowArgs} args - Arguments to find a RegistroMedico
     * @example
     * // Get one RegistroMedico
     * const registroMedico = await prisma.registroMedico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegistroMedicoFindFirstOrThrowArgs>(args?: SelectSubset<T, RegistroMedicoFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegistroMedicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegistroMedicos
     * const registroMedicos = await prisma.registroMedico.findMany()
     * 
     * // Get first 10 RegistroMedicos
     * const registroMedicos = await prisma.registroMedico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registroMedicoWithIdOnly = await prisma.registroMedico.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegistroMedicoFindManyArgs>(args?: SelectSubset<T, RegistroMedicoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegistroMedico.
     * @param {RegistroMedicoCreateArgs} args - Arguments to create a RegistroMedico.
     * @example
     * // Create one RegistroMedico
     * const RegistroMedico = await prisma.registroMedico.create({
     *   data: {
     *     // ... data to create a RegistroMedico
     *   }
     * })
     * 
     */
    create<T extends RegistroMedicoCreateArgs>(args: SelectSubset<T, RegistroMedicoCreateArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegistroMedicos.
     * @param {RegistroMedicoCreateManyArgs} args - Arguments to create many RegistroMedicos.
     * @example
     * // Create many RegistroMedicos
     * const registroMedico = await prisma.registroMedico.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegistroMedicoCreateManyArgs>(args?: SelectSubset<T, RegistroMedicoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegistroMedicos and returns the data saved in the database.
     * @param {RegistroMedicoCreateManyAndReturnArgs} args - Arguments to create many RegistroMedicos.
     * @example
     * // Create many RegistroMedicos
     * const registroMedico = await prisma.registroMedico.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegistroMedicos and only return the `id`
     * const registroMedicoWithIdOnly = await prisma.registroMedico.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegistroMedicoCreateManyAndReturnArgs>(args?: SelectSubset<T, RegistroMedicoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RegistroMedico.
     * @param {RegistroMedicoDeleteArgs} args - Arguments to delete one RegistroMedico.
     * @example
     * // Delete one RegistroMedico
     * const RegistroMedico = await prisma.registroMedico.delete({
     *   where: {
     *     // ... filter to delete one RegistroMedico
     *   }
     * })
     * 
     */
    delete<T extends RegistroMedicoDeleteArgs>(args: SelectSubset<T, RegistroMedicoDeleteArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegistroMedico.
     * @param {RegistroMedicoUpdateArgs} args - Arguments to update one RegistroMedico.
     * @example
     * // Update one RegistroMedico
     * const registroMedico = await prisma.registroMedico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegistroMedicoUpdateArgs>(args: SelectSubset<T, RegistroMedicoUpdateArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegistroMedicos.
     * @param {RegistroMedicoDeleteManyArgs} args - Arguments to filter RegistroMedicos to delete.
     * @example
     * // Delete a few RegistroMedicos
     * const { count } = await prisma.registroMedico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegistroMedicoDeleteManyArgs>(args?: SelectSubset<T, RegistroMedicoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegistroMedicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegistroMedicos
     * const registroMedico = await prisma.registroMedico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegistroMedicoUpdateManyArgs>(args: SelectSubset<T, RegistroMedicoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegistroMedicos and returns the data updated in the database.
     * @param {RegistroMedicoUpdateManyAndReturnArgs} args - Arguments to update many RegistroMedicos.
     * @example
     * // Update many RegistroMedicos
     * const registroMedico = await prisma.registroMedico.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RegistroMedicos and only return the `id`
     * const registroMedicoWithIdOnly = await prisma.registroMedico.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegistroMedicoUpdateManyAndReturnArgs>(args: SelectSubset<T, RegistroMedicoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RegistroMedico.
     * @param {RegistroMedicoUpsertArgs} args - Arguments to update or create a RegistroMedico.
     * @example
     * // Update or create a RegistroMedico
     * const registroMedico = await prisma.registroMedico.upsert({
     *   create: {
     *     // ... data to create a RegistroMedico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegistroMedico we want to update
     *   }
     * })
     */
    upsert<T extends RegistroMedicoUpsertArgs>(args: SelectSubset<T, RegistroMedicoUpsertArgs<ExtArgs>>): Prisma__RegistroMedicoClient<$Result.GetResult<Prisma.$RegistroMedicoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegistroMedicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoCountArgs} args - Arguments to filter RegistroMedicos to count.
     * @example
     * // Count the number of RegistroMedicos
     * const count = await prisma.registroMedico.count({
     *   where: {
     *     // ... the filter for the RegistroMedicos we want to count
     *   }
     * })
    **/
    count<T extends RegistroMedicoCountArgs>(
      args?: Subset<T, RegistroMedicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistroMedicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegistroMedico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistroMedicoAggregateArgs>(args: Subset<T, RegistroMedicoAggregateArgs>): Prisma.PrismaPromise<GetRegistroMedicoAggregateType<T>>

    /**
     * Group by RegistroMedico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroMedicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegistroMedicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegistroMedicoGroupByArgs['orderBy'] }
        : { orderBy?: RegistroMedicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegistroMedicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistroMedicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegistroMedico model
   */
  readonly fields: RegistroMedicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegistroMedico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegistroMedicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animal<T extends AnimalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimalDefaultArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    veterinario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegistroMedico model
   */
  interface RegistroMedicoFieldRefs {
    readonly id: FieldRef<"RegistroMedico", 'Int'>
    readonly animalId: FieldRef<"RegistroMedico", 'Int'>
    readonly veterinarioId: FieldRef<"RegistroMedico", 'Int'>
    readonly descripcion: FieldRef<"RegistroMedico", 'String'>
    readonly fecha: FieldRef<"RegistroMedico", 'DateTime'>
    readonly tipo: FieldRef<"RegistroMedico", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RegistroMedico findUnique
   */
  export type RegistroMedicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroMedico to fetch.
     */
    where: RegistroMedicoWhereUniqueInput
  }

  /**
   * RegistroMedico findUniqueOrThrow
   */
  export type RegistroMedicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroMedico to fetch.
     */
    where: RegistroMedicoWhereUniqueInput
  }

  /**
   * RegistroMedico findFirst
   */
  export type RegistroMedicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroMedico to fetch.
     */
    where?: RegistroMedicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroMedicos to fetch.
     */
    orderBy?: RegistroMedicoOrderByWithRelationInput | RegistroMedicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroMedicos.
     */
    cursor?: RegistroMedicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroMedicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroMedicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroMedicos.
     */
    distinct?: RegistroMedicoScalarFieldEnum | RegistroMedicoScalarFieldEnum[]
  }

  /**
   * RegistroMedico findFirstOrThrow
   */
  export type RegistroMedicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroMedico to fetch.
     */
    where?: RegistroMedicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroMedicos to fetch.
     */
    orderBy?: RegistroMedicoOrderByWithRelationInput | RegistroMedicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroMedicos.
     */
    cursor?: RegistroMedicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroMedicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroMedicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroMedicos.
     */
    distinct?: RegistroMedicoScalarFieldEnum | RegistroMedicoScalarFieldEnum[]
  }

  /**
   * RegistroMedico findMany
   */
  export type RegistroMedicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * Filter, which RegistroMedicos to fetch.
     */
    where?: RegistroMedicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroMedicos to fetch.
     */
    orderBy?: RegistroMedicoOrderByWithRelationInput | RegistroMedicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegistroMedicos.
     */
    cursor?: RegistroMedicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroMedicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroMedicos.
     */
    skip?: number
    distinct?: RegistroMedicoScalarFieldEnum | RegistroMedicoScalarFieldEnum[]
  }

  /**
   * RegistroMedico create
   */
  export type RegistroMedicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * The data needed to create a RegistroMedico.
     */
    data: XOR<RegistroMedicoCreateInput, RegistroMedicoUncheckedCreateInput>
  }

  /**
   * RegistroMedico createMany
   */
  export type RegistroMedicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegistroMedicos.
     */
    data: RegistroMedicoCreateManyInput | RegistroMedicoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegistroMedico createManyAndReturn
   */
  export type RegistroMedicoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * The data used to create many RegistroMedicos.
     */
    data: RegistroMedicoCreateManyInput | RegistroMedicoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegistroMedico update
   */
  export type RegistroMedicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * The data needed to update a RegistroMedico.
     */
    data: XOR<RegistroMedicoUpdateInput, RegistroMedicoUncheckedUpdateInput>
    /**
     * Choose, which RegistroMedico to update.
     */
    where: RegistroMedicoWhereUniqueInput
  }

  /**
   * RegistroMedico updateMany
   */
  export type RegistroMedicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegistroMedicos.
     */
    data: XOR<RegistroMedicoUpdateManyMutationInput, RegistroMedicoUncheckedUpdateManyInput>
    /**
     * Filter which RegistroMedicos to update
     */
    where?: RegistroMedicoWhereInput
    /**
     * Limit how many RegistroMedicos to update.
     */
    limit?: number
  }

  /**
   * RegistroMedico updateManyAndReturn
   */
  export type RegistroMedicoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * The data used to update RegistroMedicos.
     */
    data: XOR<RegistroMedicoUpdateManyMutationInput, RegistroMedicoUncheckedUpdateManyInput>
    /**
     * Filter which RegistroMedicos to update
     */
    where?: RegistroMedicoWhereInput
    /**
     * Limit how many RegistroMedicos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegistroMedico upsert
   */
  export type RegistroMedicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * The filter to search for the RegistroMedico to update in case it exists.
     */
    where: RegistroMedicoWhereUniqueInput
    /**
     * In case the RegistroMedico found by the `where` argument doesn't exist, create a new RegistroMedico with this data.
     */
    create: XOR<RegistroMedicoCreateInput, RegistroMedicoUncheckedCreateInput>
    /**
     * In case the RegistroMedico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegistroMedicoUpdateInput, RegistroMedicoUncheckedUpdateInput>
  }

  /**
   * RegistroMedico delete
   */
  export type RegistroMedicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
    /**
     * Filter which RegistroMedico to delete.
     */
    where: RegistroMedicoWhereUniqueInput
  }

  /**
   * RegistroMedico deleteMany
   */
  export type RegistroMedicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroMedicos to delete
     */
    where?: RegistroMedicoWhereInput
    /**
     * Limit how many RegistroMedicos to delete.
     */
    limit?: number
  }

  /**
   * RegistroMedico without action
   */
  export type RegistroMedicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroMedico
     */
    select?: RegistroMedicoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegistroMedico
     */
    omit?: RegistroMedicoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroMedicoInclude<ExtArgs> | null
  }


  /**
   * Model Voluntariado
   */

  export type AggregateVoluntariado = {
    _count: VoluntariadoCountAggregateOutputType | null
    _avg: VoluntariadoAvgAggregateOutputType | null
    _sum: VoluntariadoSumAggregateOutputType | null
    _min: VoluntariadoMinAggregateOutputType | null
    _max: VoluntariadoMaxAggregateOutputType | null
  }

  export type VoluntariadoAvgAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type VoluntariadoSumAggregateOutputType = {
    id: number | null
    usuarioId: number | null
  }

  export type VoluntariadoMinAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    actividad: string | null
    fecha: Date | null
    estado: string | null
  }

  export type VoluntariadoMaxAggregateOutputType = {
    id: number | null
    usuarioId: number | null
    actividad: string | null
    fecha: Date | null
    estado: string | null
  }

  export type VoluntariadoCountAggregateOutputType = {
    id: number
    usuarioId: number
    actividad: number
    fecha: number
    estado: number
    _all: number
  }


  export type VoluntariadoAvgAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type VoluntariadoSumAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type VoluntariadoMinAggregateInputType = {
    id?: true
    usuarioId?: true
    actividad?: true
    fecha?: true
    estado?: true
  }

  export type VoluntariadoMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    actividad?: true
    fecha?: true
    estado?: true
  }

  export type VoluntariadoCountAggregateInputType = {
    id?: true
    usuarioId?: true
    actividad?: true
    fecha?: true
    estado?: true
    _all?: true
  }

  export type VoluntariadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voluntariado to aggregate.
     */
    where?: VoluntariadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Voluntariados to fetch.
     */
    orderBy?: VoluntariadoOrderByWithRelationInput | VoluntariadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoluntariadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Voluntariados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Voluntariados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Voluntariados
    **/
    _count?: true | VoluntariadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VoluntariadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VoluntariadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoluntariadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoluntariadoMaxAggregateInputType
  }

  export type GetVoluntariadoAggregateType<T extends VoluntariadoAggregateArgs> = {
        [P in keyof T & keyof AggregateVoluntariado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVoluntariado[P]>
      : GetScalarType<T[P], AggregateVoluntariado[P]>
  }




  export type VoluntariadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoluntariadoWhereInput
    orderBy?: VoluntariadoOrderByWithAggregationInput | VoluntariadoOrderByWithAggregationInput[]
    by: VoluntariadoScalarFieldEnum[] | VoluntariadoScalarFieldEnum
    having?: VoluntariadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoluntariadoCountAggregateInputType | true
    _avg?: VoluntariadoAvgAggregateInputType
    _sum?: VoluntariadoSumAggregateInputType
    _min?: VoluntariadoMinAggregateInputType
    _max?: VoluntariadoMaxAggregateInputType
  }

  export type VoluntariadoGroupByOutputType = {
    id: number
    usuarioId: number
    actividad: string
    fecha: Date
    estado: string
    _count: VoluntariadoCountAggregateOutputType | null
    _avg: VoluntariadoAvgAggregateOutputType | null
    _sum: VoluntariadoSumAggregateOutputType | null
    _min: VoluntariadoMinAggregateOutputType | null
    _max: VoluntariadoMaxAggregateOutputType | null
  }

  type GetVoluntariadoGroupByPayload<T extends VoluntariadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoluntariadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoluntariadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoluntariadoGroupByOutputType[P]>
            : GetScalarType<T[P], VoluntariadoGroupByOutputType[P]>
        }
      >
    >


  export type VoluntariadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    actividad?: boolean
    fecha?: boolean
    estado?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voluntariado"]>

  export type VoluntariadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    actividad?: boolean
    fecha?: boolean
    estado?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voluntariado"]>

  export type VoluntariadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    actividad?: boolean
    fecha?: boolean
    estado?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["voluntariado"]>

  export type VoluntariadoSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    actividad?: boolean
    fecha?: boolean
    estado?: boolean
  }

  export type VoluntariadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuarioId" | "actividad" | "fecha" | "estado", ExtArgs["result"]["voluntariado"]>
  export type VoluntariadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type VoluntariadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type VoluntariadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $VoluntariadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Voluntariado"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuarioId: number
      actividad: string
      fecha: Date
      estado: string
    }, ExtArgs["result"]["voluntariado"]>
    composites: {}
  }

  type VoluntariadoGetPayload<S extends boolean | null | undefined | VoluntariadoDefaultArgs> = $Result.GetResult<Prisma.$VoluntariadoPayload, S>

  type VoluntariadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoluntariadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoluntariadoCountAggregateInputType | true
    }

  export interface VoluntariadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Voluntariado'], meta: { name: 'Voluntariado' } }
    /**
     * Find zero or one Voluntariado that matches the filter.
     * @param {VoluntariadoFindUniqueArgs} args - Arguments to find a Voluntariado
     * @example
     * // Get one Voluntariado
     * const voluntariado = await prisma.voluntariado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoluntariadoFindUniqueArgs>(args: SelectSubset<T, VoluntariadoFindUniqueArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Voluntariado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoluntariadoFindUniqueOrThrowArgs} args - Arguments to find a Voluntariado
     * @example
     * // Get one Voluntariado
     * const voluntariado = await prisma.voluntariado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoluntariadoFindUniqueOrThrowArgs>(args: SelectSubset<T, VoluntariadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voluntariado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoFindFirstArgs} args - Arguments to find a Voluntariado
     * @example
     * // Get one Voluntariado
     * const voluntariado = await prisma.voluntariado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoluntariadoFindFirstArgs>(args?: SelectSubset<T, VoluntariadoFindFirstArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Voluntariado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoFindFirstOrThrowArgs} args - Arguments to find a Voluntariado
     * @example
     * // Get one Voluntariado
     * const voluntariado = await prisma.voluntariado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoluntariadoFindFirstOrThrowArgs>(args?: SelectSubset<T, VoluntariadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Voluntariados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Voluntariados
     * const voluntariados = await prisma.voluntariado.findMany()
     * 
     * // Get first 10 Voluntariados
     * const voluntariados = await prisma.voluntariado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voluntariadoWithIdOnly = await prisma.voluntariado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoluntariadoFindManyArgs>(args?: SelectSubset<T, VoluntariadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Voluntariado.
     * @param {VoluntariadoCreateArgs} args - Arguments to create a Voluntariado.
     * @example
     * // Create one Voluntariado
     * const Voluntariado = await prisma.voluntariado.create({
     *   data: {
     *     // ... data to create a Voluntariado
     *   }
     * })
     * 
     */
    create<T extends VoluntariadoCreateArgs>(args: SelectSubset<T, VoluntariadoCreateArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Voluntariados.
     * @param {VoluntariadoCreateManyArgs} args - Arguments to create many Voluntariados.
     * @example
     * // Create many Voluntariados
     * const voluntariado = await prisma.voluntariado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoluntariadoCreateManyArgs>(args?: SelectSubset<T, VoluntariadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Voluntariados and returns the data saved in the database.
     * @param {VoluntariadoCreateManyAndReturnArgs} args - Arguments to create many Voluntariados.
     * @example
     * // Create many Voluntariados
     * const voluntariado = await prisma.voluntariado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Voluntariados and only return the `id`
     * const voluntariadoWithIdOnly = await prisma.voluntariado.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoluntariadoCreateManyAndReturnArgs>(args?: SelectSubset<T, VoluntariadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Voluntariado.
     * @param {VoluntariadoDeleteArgs} args - Arguments to delete one Voluntariado.
     * @example
     * // Delete one Voluntariado
     * const Voluntariado = await prisma.voluntariado.delete({
     *   where: {
     *     // ... filter to delete one Voluntariado
     *   }
     * })
     * 
     */
    delete<T extends VoluntariadoDeleteArgs>(args: SelectSubset<T, VoluntariadoDeleteArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Voluntariado.
     * @param {VoluntariadoUpdateArgs} args - Arguments to update one Voluntariado.
     * @example
     * // Update one Voluntariado
     * const voluntariado = await prisma.voluntariado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoluntariadoUpdateArgs>(args: SelectSubset<T, VoluntariadoUpdateArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Voluntariados.
     * @param {VoluntariadoDeleteManyArgs} args - Arguments to filter Voluntariados to delete.
     * @example
     * // Delete a few Voluntariados
     * const { count } = await prisma.voluntariado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoluntariadoDeleteManyArgs>(args?: SelectSubset<T, VoluntariadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voluntariados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Voluntariados
     * const voluntariado = await prisma.voluntariado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoluntariadoUpdateManyArgs>(args: SelectSubset<T, VoluntariadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Voluntariados and returns the data updated in the database.
     * @param {VoluntariadoUpdateManyAndReturnArgs} args - Arguments to update many Voluntariados.
     * @example
     * // Update many Voluntariados
     * const voluntariado = await prisma.voluntariado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Voluntariados and only return the `id`
     * const voluntariadoWithIdOnly = await prisma.voluntariado.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoluntariadoUpdateManyAndReturnArgs>(args: SelectSubset<T, VoluntariadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Voluntariado.
     * @param {VoluntariadoUpsertArgs} args - Arguments to update or create a Voluntariado.
     * @example
     * // Update or create a Voluntariado
     * const voluntariado = await prisma.voluntariado.upsert({
     *   create: {
     *     // ... data to create a Voluntariado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Voluntariado we want to update
     *   }
     * })
     */
    upsert<T extends VoluntariadoUpsertArgs>(args: SelectSubset<T, VoluntariadoUpsertArgs<ExtArgs>>): Prisma__VoluntariadoClient<$Result.GetResult<Prisma.$VoluntariadoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Voluntariados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoCountArgs} args - Arguments to filter Voluntariados to count.
     * @example
     * // Count the number of Voluntariados
     * const count = await prisma.voluntariado.count({
     *   where: {
     *     // ... the filter for the Voluntariados we want to count
     *   }
     * })
    **/
    count<T extends VoluntariadoCountArgs>(
      args?: Subset<T, VoluntariadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoluntariadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Voluntariado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoluntariadoAggregateArgs>(args: Subset<T, VoluntariadoAggregateArgs>): Prisma.PrismaPromise<GetVoluntariadoAggregateType<T>>

    /**
     * Group by Voluntariado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoluntariadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoluntariadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoluntariadoGroupByArgs['orderBy'] }
        : { orderBy?: VoluntariadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoluntariadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoluntariadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Voluntariado model
   */
  readonly fields: VoluntariadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Voluntariado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoluntariadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Voluntariado model
   */
  interface VoluntariadoFieldRefs {
    readonly id: FieldRef<"Voluntariado", 'Int'>
    readonly usuarioId: FieldRef<"Voluntariado", 'Int'>
    readonly actividad: FieldRef<"Voluntariado", 'String'>
    readonly fecha: FieldRef<"Voluntariado", 'DateTime'>
    readonly estado: FieldRef<"Voluntariado", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Voluntariado findUnique
   */
  export type VoluntariadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * Filter, which Voluntariado to fetch.
     */
    where: VoluntariadoWhereUniqueInput
  }

  /**
   * Voluntariado findUniqueOrThrow
   */
  export type VoluntariadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * Filter, which Voluntariado to fetch.
     */
    where: VoluntariadoWhereUniqueInput
  }

  /**
   * Voluntariado findFirst
   */
  export type VoluntariadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * Filter, which Voluntariado to fetch.
     */
    where?: VoluntariadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Voluntariados to fetch.
     */
    orderBy?: VoluntariadoOrderByWithRelationInput | VoluntariadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Voluntariados.
     */
    cursor?: VoluntariadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Voluntariados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Voluntariados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Voluntariados.
     */
    distinct?: VoluntariadoScalarFieldEnum | VoluntariadoScalarFieldEnum[]
  }

  /**
   * Voluntariado findFirstOrThrow
   */
  export type VoluntariadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * Filter, which Voluntariado to fetch.
     */
    where?: VoluntariadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Voluntariados to fetch.
     */
    orderBy?: VoluntariadoOrderByWithRelationInput | VoluntariadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Voluntariados.
     */
    cursor?: VoluntariadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Voluntariados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Voluntariados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Voluntariados.
     */
    distinct?: VoluntariadoScalarFieldEnum | VoluntariadoScalarFieldEnum[]
  }

  /**
   * Voluntariado findMany
   */
  export type VoluntariadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * Filter, which Voluntariados to fetch.
     */
    where?: VoluntariadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Voluntariados to fetch.
     */
    orderBy?: VoluntariadoOrderByWithRelationInput | VoluntariadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Voluntariados.
     */
    cursor?: VoluntariadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Voluntariados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Voluntariados.
     */
    skip?: number
    distinct?: VoluntariadoScalarFieldEnum | VoluntariadoScalarFieldEnum[]
  }

  /**
   * Voluntariado create
   */
  export type VoluntariadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * The data needed to create a Voluntariado.
     */
    data: XOR<VoluntariadoCreateInput, VoluntariadoUncheckedCreateInput>
  }

  /**
   * Voluntariado createMany
   */
  export type VoluntariadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Voluntariados.
     */
    data: VoluntariadoCreateManyInput | VoluntariadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Voluntariado createManyAndReturn
   */
  export type VoluntariadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * The data used to create many Voluntariados.
     */
    data: VoluntariadoCreateManyInput | VoluntariadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voluntariado update
   */
  export type VoluntariadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * The data needed to update a Voluntariado.
     */
    data: XOR<VoluntariadoUpdateInput, VoluntariadoUncheckedUpdateInput>
    /**
     * Choose, which Voluntariado to update.
     */
    where: VoluntariadoWhereUniqueInput
  }

  /**
   * Voluntariado updateMany
   */
  export type VoluntariadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Voluntariados.
     */
    data: XOR<VoluntariadoUpdateManyMutationInput, VoluntariadoUncheckedUpdateManyInput>
    /**
     * Filter which Voluntariados to update
     */
    where?: VoluntariadoWhereInput
    /**
     * Limit how many Voluntariados to update.
     */
    limit?: number
  }

  /**
   * Voluntariado updateManyAndReturn
   */
  export type VoluntariadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * The data used to update Voluntariados.
     */
    data: XOR<VoluntariadoUpdateManyMutationInput, VoluntariadoUncheckedUpdateManyInput>
    /**
     * Filter which Voluntariados to update
     */
    where?: VoluntariadoWhereInput
    /**
     * Limit how many Voluntariados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Voluntariado upsert
   */
  export type VoluntariadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * The filter to search for the Voluntariado to update in case it exists.
     */
    where: VoluntariadoWhereUniqueInput
    /**
     * In case the Voluntariado found by the `where` argument doesn't exist, create a new Voluntariado with this data.
     */
    create: XOR<VoluntariadoCreateInput, VoluntariadoUncheckedCreateInput>
    /**
     * In case the Voluntariado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoluntariadoUpdateInput, VoluntariadoUncheckedUpdateInput>
  }

  /**
   * Voluntariado delete
   */
  export type VoluntariadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
    /**
     * Filter which Voluntariado to delete.
     */
    where: VoluntariadoWhereUniqueInput
  }

  /**
   * Voluntariado deleteMany
   */
  export type VoluntariadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Voluntariados to delete
     */
    where?: VoluntariadoWhereInput
    /**
     * Limit how many Voluntariados to delete.
     */
    limit?: number
  }

  /**
   * Voluntariado without action
   */
  export type VoluntariadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Voluntariado
     */
    select?: VoluntariadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Voluntariado
     */
    omit?: VoluntariadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoluntariadoInclude<ExtArgs> | null
  }


  /**
   * Model HogarTemporal
   */

  export type AggregateHogarTemporal = {
    _count: HogarTemporalCountAggregateOutputType | null
    _avg: HogarTemporalAvgAggregateOutputType | null
    _sum: HogarTemporalSumAggregateOutputType | null
    _min: HogarTemporalMinAggregateOutputType | null
    _max: HogarTemporalMaxAggregateOutputType | null
  }

  export type HogarTemporalAvgAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
  }

  export type HogarTemporalSumAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
  }

  export type HogarTemporalMinAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    estado: string | null
  }

  export type HogarTemporalMaxAggregateOutputType = {
    id: number | null
    animalId: number | null
    usuarioId: number | null
    fechaInicio: Date | null
    fechaFin: Date | null
    estado: string | null
  }

  export type HogarTemporalCountAggregateOutputType = {
    id: number
    animalId: number
    usuarioId: number
    fechaInicio: number
    fechaFin: number
    estado: number
    _all: number
  }


  export type HogarTemporalAvgAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
  }

  export type HogarTemporalSumAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
  }

  export type HogarTemporalMinAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    estado?: true
  }

  export type HogarTemporalMaxAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    estado?: true
  }

  export type HogarTemporalCountAggregateInputType = {
    id?: true
    animalId?: true
    usuarioId?: true
    fechaInicio?: true
    fechaFin?: true
    estado?: true
    _all?: true
  }

  export type HogarTemporalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HogarTemporal to aggregate.
     */
    where?: HogarTemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HogarTemporals to fetch.
     */
    orderBy?: HogarTemporalOrderByWithRelationInput | HogarTemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HogarTemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HogarTemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HogarTemporals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HogarTemporals
    **/
    _count?: true | HogarTemporalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HogarTemporalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HogarTemporalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HogarTemporalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HogarTemporalMaxAggregateInputType
  }

  export type GetHogarTemporalAggregateType<T extends HogarTemporalAggregateArgs> = {
        [P in keyof T & keyof AggregateHogarTemporal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHogarTemporal[P]>
      : GetScalarType<T[P], AggregateHogarTemporal[P]>
  }




  export type HogarTemporalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HogarTemporalWhereInput
    orderBy?: HogarTemporalOrderByWithAggregationInput | HogarTemporalOrderByWithAggregationInput[]
    by: HogarTemporalScalarFieldEnum[] | HogarTemporalScalarFieldEnum
    having?: HogarTemporalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HogarTemporalCountAggregateInputType | true
    _avg?: HogarTemporalAvgAggregateInputType
    _sum?: HogarTemporalSumAggregateInputType
    _min?: HogarTemporalMinAggregateInputType
    _max?: HogarTemporalMaxAggregateInputType
  }

  export type HogarTemporalGroupByOutputType = {
    id: number
    animalId: number
    usuarioId: number
    fechaInicio: Date
    fechaFin: Date | null
    estado: string
    _count: HogarTemporalCountAggregateOutputType | null
    _avg: HogarTemporalAvgAggregateOutputType | null
    _sum: HogarTemporalSumAggregateOutputType | null
    _min: HogarTemporalMinAggregateOutputType | null
    _max: HogarTemporalMaxAggregateOutputType | null
  }

  type GetHogarTemporalGroupByPayload<T extends HogarTemporalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HogarTemporalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HogarTemporalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HogarTemporalGroupByOutputType[P]>
            : GetScalarType<T[P], HogarTemporalGroupByOutputType[P]>
        }
      >
    >


  export type HogarTemporalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hogarTemporal"]>

  export type HogarTemporalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hogarTemporal"]>

  export type HogarTemporalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hogarTemporal"]>

  export type HogarTemporalSelectScalar = {
    id?: boolean
    animalId?: boolean
    usuarioId?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    estado?: boolean
  }

  export type HogarTemporalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animalId" | "usuarioId" | "fechaInicio" | "fechaFin" | "estado", ExtArgs["result"]["hogarTemporal"]>
  export type HogarTemporalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type HogarTemporalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type HogarTemporalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animal?: boolean | AnimalDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $HogarTemporalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HogarTemporal"
    objects: {
      animal: Prisma.$AnimalPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      animalId: number
      usuarioId: number
      fechaInicio: Date
      fechaFin: Date | null
      estado: string
    }, ExtArgs["result"]["hogarTemporal"]>
    composites: {}
  }

  type HogarTemporalGetPayload<S extends boolean | null | undefined | HogarTemporalDefaultArgs> = $Result.GetResult<Prisma.$HogarTemporalPayload, S>

  type HogarTemporalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HogarTemporalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HogarTemporalCountAggregateInputType | true
    }

  export interface HogarTemporalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HogarTemporal'], meta: { name: 'HogarTemporal' } }
    /**
     * Find zero or one HogarTemporal that matches the filter.
     * @param {HogarTemporalFindUniqueArgs} args - Arguments to find a HogarTemporal
     * @example
     * // Get one HogarTemporal
     * const hogarTemporal = await prisma.hogarTemporal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HogarTemporalFindUniqueArgs>(args: SelectSubset<T, HogarTemporalFindUniqueArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HogarTemporal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HogarTemporalFindUniqueOrThrowArgs} args - Arguments to find a HogarTemporal
     * @example
     * // Get one HogarTemporal
     * const hogarTemporal = await prisma.hogarTemporal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HogarTemporalFindUniqueOrThrowArgs>(args: SelectSubset<T, HogarTemporalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HogarTemporal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalFindFirstArgs} args - Arguments to find a HogarTemporal
     * @example
     * // Get one HogarTemporal
     * const hogarTemporal = await prisma.hogarTemporal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HogarTemporalFindFirstArgs>(args?: SelectSubset<T, HogarTemporalFindFirstArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HogarTemporal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalFindFirstOrThrowArgs} args - Arguments to find a HogarTemporal
     * @example
     * // Get one HogarTemporal
     * const hogarTemporal = await prisma.hogarTemporal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HogarTemporalFindFirstOrThrowArgs>(args?: SelectSubset<T, HogarTemporalFindFirstOrThrowArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HogarTemporals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HogarTemporals
     * const hogarTemporals = await prisma.hogarTemporal.findMany()
     * 
     * // Get first 10 HogarTemporals
     * const hogarTemporals = await prisma.hogarTemporal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hogarTemporalWithIdOnly = await prisma.hogarTemporal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HogarTemporalFindManyArgs>(args?: SelectSubset<T, HogarTemporalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HogarTemporal.
     * @param {HogarTemporalCreateArgs} args - Arguments to create a HogarTemporal.
     * @example
     * // Create one HogarTemporal
     * const HogarTemporal = await prisma.hogarTemporal.create({
     *   data: {
     *     // ... data to create a HogarTemporal
     *   }
     * })
     * 
     */
    create<T extends HogarTemporalCreateArgs>(args: SelectSubset<T, HogarTemporalCreateArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HogarTemporals.
     * @param {HogarTemporalCreateManyArgs} args - Arguments to create many HogarTemporals.
     * @example
     * // Create many HogarTemporals
     * const hogarTemporal = await prisma.hogarTemporal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HogarTemporalCreateManyArgs>(args?: SelectSubset<T, HogarTemporalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HogarTemporals and returns the data saved in the database.
     * @param {HogarTemporalCreateManyAndReturnArgs} args - Arguments to create many HogarTemporals.
     * @example
     * // Create many HogarTemporals
     * const hogarTemporal = await prisma.hogarTemporal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HogarTemporals and only return the `id`
     * const hogarTemporalWithIdOnly = await prisma.hogarTemporal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HogarTemporalCreateManyAndReturnArgs>(args?: SelectSubset<T, HogarTemporalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HogarTemporal.
     * @param {HogarTemporalDeleteArgs} args - Arguments to delete one HogarTemporal.
     * @example
     * // Delete one HogarTemporal
     * const HogarTemporal = await prisma.hogarTemporal.delete({
     *   where: {
     *     // ... filter to delete one HogarTemporal
     *   }
     * })
     * 
     */
    delete<T extends HogarTemporalDeleteArgs>(args: SelectSubset<T, HogarTemporalDeleteArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HogarTemporal.
     * @param {HogarTemporalUpdateArgs} args - Arguments to update one HogarTemporal.
     * @example
     * // Update one HogarTemporal
     * const hogarTemporal = await prisma.hogarTemporal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HogarTemporalUpdateArgs>(args: SelectSubset<T, HogarTemporalUpdateArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HogarTemporals.
     * @param {HogarTemporalDeleteManyArgs} args - Arguments to filter HogarTemporals to delete.
     * @example
     * // Delete a few HogarTemporals
     * const { count } = await prisma.hogarTemporal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HogarTemporalDeleteManyArgs>(args?: SelectSubset<T, HogarTemporalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HogarTemporals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HogarTemporals
     * const hogarTemporal = await prisma.hogarTemporal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HogarTemporalUpdateManyArgs>(args: SelectSubset<T, HogarTemporalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HogarTemporals and returns the data updated in the database.
     * @param {HogarTemporalUpdateManyAndReturnArgs} args - Arguments to update many HogarTemporals.
     * @example
     * // Update many HogarTemporals
     * const hogarTemporal = await prisma.hogarTemporal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HogarTemporals and only return the `id`
     * const hogarTemporalWithIdOnly = await prisma.hogarTemporal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HogarTemporalUpdateManyAndReturnArgs>(args: SelectSubset<T, HogarTemporalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HogarTemporal.
     * @param {HogarTemporalUpsertArgs} args - Arguments to update or create a HogarTemporal.
     * @example
     * // Update or create a HogarTemporal
     * const hogarTemporal = await prisma.hogarTemporal.upsert({
     *   create: {
     *     // ... data to create a HogarTemporal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HogarTemporal we want to update
     *   }
     * })
     */
    upsert<T extends HogarTemporalUpsertArgs>(args: SelectSubset<T, HogarTemporalUpsertArgs<ExtArgs>>): Prisma__HogarTemporalClient<$Result.GetResult<Prisma.$HogarTemporalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HogarTemporals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalCountArgs} args - Arguments to filter HogarTemporals to count.
     * @example
     * // Count the number of HogarTemporals
     * const count = await prisma.hogarTemporal.count({
     *   where: {
     *     // ... the filter for the HogarTemporals we want to count
     *   }
     * })
    **/
    count<T extends HogarTemporalCountArgs>(
      args?: Subset<T, HogarTemporalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HogarTemporalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HogarTemporal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HogarTemporalAggregateArgs>(args: Subset<T, HogarTemporalAggregateArgs>): Prisma.PrismaPromise<GetHogarTemporalAggregateType<T>>

    /**
     * Group by HogarTemporal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HogarTemporalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HogarTemporalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HogarTemporalGroupByArgs['orderBy'] }
        : { orderBy?: HogarTemporalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HogarTemporalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHogarTemporalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HogarTemporal model
   */
  readonly fields: HogarTemporalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HogarTemporal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HogarTemporalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animal<T extends AnimalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimalDefaultArgs<ExtArgs>>): Prisma__AnimalClient<$Result.GetResult<Prisma.$AnimalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HogarTemporal model
   */
  interface HogarTemporalFieldRefs {
    readonly id: FieldRef<"HogarTemporal", 'Int'>
    readonly animalId: FieldRef<"HogarTemporal", 'Int'>
    readonly usuarioId: FieldRef<"HogarTemporal", 'Int'>
    readonly fechaInicio: FieldRef<"HogarTemporal", 'DateTime'>
    readonly fechaFin: FieldRef<"HogarTemporal", 'DateTime'>
    readonly estado: FieldRef<"HogarTemporal", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HogarTemporal findUnique
   */
  export type HogarTemporalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * Filter, which HogarTemporal to fetch.
     */
    where: HogarTemporalWhereUniqueInput
  }

  /**
   * HogarTemporal findUniqueOrThrow
   */
  export type HogarTemporalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * Filter, which HogarTemporal to fetch.
     */
    where: HogarTemporalWhereUniqueInput
  }

  /**
   * HogarTemporal findFirst
   */
  export type HogarTemporalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * Filter, which HogarTemporal to fetch.
     */
    where?: HogarTemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HogarTemporals to fetch.
     */
    orderBy?: HogarTemporalOrderByWithRelationInput | HogarTemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HogarTemporals.
     */
    cursor?: HogarTemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HogarTemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HogarTemporals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HogarTemporals.
     */
    distinct?: HogarTemporalScalarFieldEnum | HogarTemporalScalarFieldEnum[]
  }

  /**
   * HogarTemporal findFirstOrThrow
   */
  export type HogarTemporalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * Filter, which HogarTemporal to fetch.
     */
    where?: HogarTemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HogarTemporals to fetch.
     */
    orderBy?: HogarTemporalOrderByWithRelationInput | HogarTemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HogarTemporals.
     */
    cursor?: HogarTemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HogarTemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HogarTemporals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HogarTemporals.
     */
    distinct?: HogarTemporalScalarFieldEnum | HogarTemporalScalarFieldEnum[]
  }

  /**
   * HogarTemporal findMany
   */
  export type HogarTemporalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * Filter, which HogarTemporals to fetch.
     */
    where?: HogarTemporalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HogarTemporals to fetch.
     */
    orderBy?: HogarTemporalOrderByWithRelationInput | HogarTemporalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HogarTemporals.
     */
    cursor?: HogarTemporalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HogarTemporals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HogarTemporals.
     */
    skip?: number
    distinct?: HogarTemporalScalarFieldEnum | HogarTemporalScalarFieldEnum[]
  }

  /**
   * HogarTemporal create
   */
  export type HogarTemporalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * The data needed to create a HogarTemporal.
     */
    data: XOR<HogarTemporalCreateInput, HogarTemporalUncheckedCreateInput>
  }

  /**
   * HogarTemporal createMany
   */
  export type HogarTemporalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HogarTemporals.
     */
    data: HogarTemporalCreateManyInput | HogarTemporalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HogarTemporal createManyAndReturn
   */
  export type HogarTemporalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * The data used to create many HogarTemporals.
     */
    data: HogarTemporalCreateManyInput | HogarTemporalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HogarTemporal update
   */
  export type HogarTemporalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * The data needed to update a HogarTemporal.
     */
    data: XOR<HogarTemporalUpdateInput, HogarTemporalUncheckedUpdateInput>
    /**
     * Choose, which HogarTemporal to update.
     */
    where: HogarTemporalWhereUniqueInput
  }

  /**
   * HogarTemporal updateMany
   */
  export type HogarTemporalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HogarTemporals.
     */
    data: XOR<HogarTemporalUpdateManyMutationInput, HogarTemporalUncheckedUpdateManyInput>
    /**
     * Filter which HogarTemporals to update
     */
    where?: HogarTemporalWhereInput
    /**
     * Limit how many HogarTemporals to update.
     */
    limit?: number
  }

  /**
   * HogarTemporal updateManyAndReturn
   */
  export type HogarTemporalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * The data used to update HogarTemporals.
     */
    data: XOR<HogarTemporalUpdateManyMutationInput, HogarTemporalUncheckedUpdateManyInput>
    /**
     * Filter which HogarTemporals to update
     */
    where?: HogarTemporalWhereInput
    /**
     * Limit how many HogarTemporals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HogarTemporal upsert
   */
  export type HogarTemporalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * The filter to search for the HogarTemporal to update in case it exists.
     */
    where: HogarTemporalWhereUniqueInput
    /**
     * In case the HogarTemporal found by the `where` argument doesn't exist, create a new HogarTemporal with this data.
     */
    create: XOR<HogarTemporalCreateInput, HogarTemporalUncheckedCreateInput>
    /**
     * In case the HogarTemporal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HogarTemporalUpdateInput, HogarTemporalUncheckedUpdateInput>
  }

  /**
   * HogarTemporal delete
   */
  export type HogarTemporalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
    /**
     * Filter which HogarTemporal to delete.
     */
    where: HogarTemporalWhereUniqueInput
  }

  /**
   * HogarTemporal deleteMany
   */
  export type HogarTemporalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HogarTemporals to delete
     */
    where?: HogarTemporalWhereInput
    /**
     * Limit how many HogarTemporals to delete.
     */
    limit?: number
  }

  /**
   * HogarTemporal without action
   */
  export type HogarTemporalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HogarTemporal
     */
    select?: HogarTemporalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HogarTemporal
     */
    omit?: HogarTemporalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HogarTemporalInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    email: 'email',
    telefono: 'telefono',
    tipoUsuario: 'tipoUsuario',
    estado: 'estado',
    avatar: 'avatar',
    password: 'password',
    fechaRegistro: 'fechaRegistro'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const AnimalScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    especie: 'especie',
    raza: 'raza',
    edad: 'edad',
    estado: 'estado',
    fechaIngreso: 'fechaIngreso',
    descripcion: 'descripcion',
    foto: 'foto'
  };

  export type AnimalScalarFieldEnum = (typeof AnimalScalarFieldEnum)[keyof typeof AnimalScalarFieldEnum]


  export const AdopcionScalarFieldEnum: {
    id: 'id',
    animalId: 'animalId',
    usuarioId: 'usuarioId',
    fechaAdopcion: 'fechaAdopcion',
    estado: 'estado'
  };

  export type AdopcionScalarFieldEnum = (typeof AdopcionScalarFieldEnum)[keyof typeof AdopcionScalarFieldEnum]


  export const HistoriaExitoScalarFieldEnum: {
    id: 'id',
    animalId: 'animalId',
    titulo: 'titulo',
    descripcion: 'descripcion',
    fecha: 'fecha'
  };

  export type HistoriaExitoScalarFieldEnum = (typeof HistoriaExitoScalarFieldEnum)[keyof typeof HistoriaExitoScalarFieldEnum]


  export const DonacionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    monto: 'monto',
    fecha: 'fecha',
    tipo: 'tipo'
  };

  export type DonacionScalarFieldEnum = (typeof DonacionScalarFieldEnum)[keyof typeof DonacionScalarFieldEnum]


  export const RegistroMedicoScalarFieldEnum: {
    id: 'id',
    animalId: 'animalId',
    veterinarioId: 'veterinarioId',
    descripcion: 'descripcion',
    fecha: 'fecha',
    tipo: 'tipo'
  };

  export type RegistroMedicoScalarFieldEnum = (typeof RegistroMedicoScalarFieldEnum)[keyof typeof RegistroMedicoScalarFieldEnum]


  export const VoluntariadoScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    actividad: 'actividad',
    fecha: 'fecha',
    estado: 'estado'
  };

  export type VoluntariadoScalarFieldEnum = (typeof VoluntariadoScalarFieldEnum)[keyof typeof VoluntariadoScalarFieldEnum]


  export const HogarTemporalScalarFieldEnum: {
    id: 'id',
    animalId: 'animalId',
    usuarioId: 'usuarioId',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    estado: 'estado'
  };

  export type HogarTemporalScalarFieldEnum = (typeof HogarTemporalScalarFieldEnum)[keyof typeof HogarTemporalScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: IntFilter<"Usuario"> | number
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringNullableFilter<"Usuario"> | string | null
    email?: StringFilter<"Usuario"> | string
    telefono?: StringNullableFilter<"Usuario"> | string | null
    tipoUsuario?: StringFilter<"Usuario"> | string
    estado?: StringFilter<"Usuario"> | string
    avatar?: StringNullableFilter<"Usuario"> | string | null
    password?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    adopciones?: AdopcionListRelationFilter
    donaciones?: DonacionListRelationFilter
    voluntariados?: VoluntariadoListRelationFilter
    registrosMedicos?: RegistroMedicoListRelationFilter
    hogaresTemporales?: HogarTemporalListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    tipoUsuario?: SortOrder
    estado?: SortOrder
    avatar?: SortOrderInput | SortOrder
    password?: SortOrder
    fechaRegistro?: SortOrder
    adopciones?: AdopcionOrderByRelationAggregateInput
    donaciones?: DonacionOrderByRelationAggregateInput
    voluntariados?: VoluntariadoOrderByRelationAggregateInput
    registrosMedicos?: RegistroMedicoOrderByRelationAggregateInput
    hogaresTemporales?: HogarTemporalOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombre?: StringFilter<"Usuario"> | string
    apellido?: StringNullableFilter<"Usuario"> | string | null
    telefono?: StringNullableFilter<"Usuario"> | string | null
    tipoUsuario?: StringFilter<"Usuario"> | string
    estado?: StringFilter<"Usuario"> | string
    avatar?: StringNullableFilter<"Usuario"> | string | null
    password?: StringFilter<"Usuario"> | string
    fechaRegistro?: DateTimeFilter<"Usuario"> | Date | string
    adopciones?: AdopcionListRelationFilter
    donaciones?: DonacionListRelationFilter
    voluntariados?: VoluntariadoListRelationFilter
    registrosMedicos?: RegistroMedicoListRelationFilter
    hogaresTemporales?: HogarTemporalListRelationFilter
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrderInput | SortOrder
    email?: SortOrder
    telefono?: SortOrderInput | SortOrder
    tipoUsuario?: SortOrder
    estado?: SortOrder
    avatar?: SortOrderInput | SortOrder
    password?: SortOrder
    fechaRegistro?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuario"> | number
    nombre?: StringWithAggregatesFilter<"Usuario"> | string
    apellido?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    email?: StringWithAggregatesFilter<"Usuario"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    tipoUsuario?: StringWithAggregatesFilter<"Usuario"> | string
    estado?: StringWithAggregatesFilter<"Usuario"> | string
    avatar?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    password?: StringWithAggregatesFilter<"Usuario"> | string
    fechaRegistro?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type AnimalWhereInput = {
    AND?: AnimalWhereInput | AnimalWhereInput[]
    OR?: AnimalWhereInput[]
    NOT?: AnimalWhereInput | AnimalWhereInput[]
    id?: IntFilter<"Animal"> | number
    nombre?: StringFilter<"Animal"> | string
    especie?: StringFilter<"Animal"> | string
    raza?: StringNullableFilter<"Animal"> | string | null
    edad?: IntNullableFilter<"Animal"> | number | null
    estado?: StringFilter<"Animal"> | string
    fechaIngreso?: DateTimeFilter<"Animal"> | Date | string
    descripcion?: StringNullableFilter<"Animal"> | string | null
    foto?: StringNullableFilter<"Animal"> | string | null
    adopciones?: AdopcionListRelationFilter
    historias?: HistoriaExitoListRelationFilter
    registrosMedicos?: RegistroMedicoListRelationFilter
    hogaresTemporales?: HogarTemporalListRelationFilter
  }

  export type AnimalOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    especie?: SortOrder
    raza?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaIngreso?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    adopciones?: AdopcionOrderByRelationAggregateInput
    historias?: HistoriaExitoOrderByRelationAggregateInput
    registrosMedicos?: RegistroMedicoOrderByRelationAggregateInput
    hogaresTemporales?: HogarTemporalOrderByRelationAggregateInput
  }

  export type AnimalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AnimalWhereInput | AnimalWhereInput[]
    OR?: AnimalWhereInput[]
    NOT?: AnimalWhereInput | AnimalWhereInput[]
    nombre?: StringFilter<"Animal"> | string
    especie?: StringFilter<"Animal"> | string
    raza?: StringNullableFilter<"Animal"> | string | null
    edad?: IntNullableFilter<"Animal"> | number | null
    estado?: StringFilter<"Animal"> | string
    fechaIngreso?: DateTimeFilter<"Animal"> | Date | string
    descripcion?: StringNullableFilter<"Animal"> | string | null
    foto?: StringNullableFilter<"Animal"> | string | null
    adopciones?: AdopcionListRelationFilter
    historias?: HistoriaExitoListRelationFilter
    registrosMedicos?: RegistroMedicoListRelationFilter
    hogaresTemporales?: HogarTemporalListRelationFilter
  }, "id">

  export type AnimalOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    especie?: SortOrder
    raza?: SortOrderInput | SortOrder
    edad?: SortOrderInput | SortOrder
    estado?: SortOrder
    fechaIngreso?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    foto?: SortOrderInput | SortOrder
    _count?: AnimalCountOrderByAggregateInput
    _avg?: AnimalAvgOrderByAggregateInput
    _max?: AnimalMaxOrderByAggregateInput
    _min?: AnimalMinOrderByAggregateInput
    _sum?: AnimalSumOrderByAggregateInput
  }

  export type AnimalScalarWhereWithAggregatesInput = {
    AND?: AnimalScalarWhereWithAggregatesInput | AnimalScalarWhereWithAggregatesInput[]
    OR?: AnimalScalarWhereWithAggregatesInput[]
    NOT?: AnimalScalarWhereWithAggregatesInput | AnimalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Animal"> | number
    nombre?: StringWithAggregatesFilter<"Animal"> | string
    especie?: StringWithAggregatesFilter<"Animal"> | string
    raza?: StringNullableWithAggregatesFilter<"Animal"> | string | null
    edad?: IntNullableWithAggregatesFilter<"Animal"> | number | null
    estado?: StringWithAggregatesFilter<"Animal"> | string
    fechaIngreso?: DateTimeWithAggregatesFilter<"Animal"> | Date | string
    descripcion?: StringNullableWithAggregatesFilter<"Animal"> | string | null
    foto?: StringNullableWithAggregatesFilter<"Animal"> | string | null
  }

  export type AdopcionWhereInput = {
    AND?: AdopcionWhereInput | AdopcionWhereInput[]
    OR?: AdopcionWhereInput[]
    NOT?: AdopcionWhereInput | AdopcionWhereInput[]
    id?: IntFilter<"Adopcion"> | number
    animalId?: IntFilter<"Adopcion"> | number
    usuarioId?: IntFilter<"Adopcion"> | number
    fechaAdopcion?: DateTimeFilter<"Adopcion"> | Date | string
    estado?: StringFilter<"Adopcion"> | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type AdopcionOrderByWithRelationInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaAdopcion?: SortOrder
    estado?: SortOrder
    animal?: AnimalOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type AdopcionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AdopcionWhereInput | AdopcionWhereInput[]
    OR?: AdopcionWhereInput[]
    NOT?: AdopcionWhereInput | AdopcionWhereInput[]
    animalId?: IntFilter<"Adopcion"> | number
    usuarioId?: IntFilter<"Adopcion"> | number
    fechaAdopcion?: DateTimeFilter<"Adopcion"> | Date | string
    estado?: StringFilter<"Adopcion"> | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type AdopcionOrderByWithAggregationInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaAdopcion?: SortOrder
    estado?: SortOrder
    _count?: AdopcionCountOrderByAggregateInput
    _avg?: AdopcionAvgOrderByAggregateInput
    _max?: AdopcionMaxOrderByAggregateInput
    _min?: AdopcionMinOrderByAggregateInput
    _sum?: AdopcionSumOrderByAggregateInput
  }

  export type AdopcionScalarWhereWithAggregatesInput = {
    AND?: AdopcionScalarWhereWithAggregatesInput | AdopcionScalarWhereWithAggregatesInput[]
    OR?: AdopcionScalarWhereWithAggregatesInput[]
    NOT?: AdopcionScalarWhereWithAggregatesInput | AdopcionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Adopcion"> | number
    animalId?: IntWithAggregatesFilter<"Adopcion"> | number
    usuarioId?: IntWithAggregatesFilter<"Adopcion"> | number
    fechaAdopcion?: DateTimeWithAggregatesFilter<"Adopcion"> | Date | string
    estado?: StringWithAggregatesFilter<"Adopcion"> | string
  }

  export type HistoriaExitoWhereInput = {
    AND?: HistoriaExitoWhereInput | HistoriaExitoWhereInput[]
    OR?: HistoriaExitoWhereInput[]
    NOT?: HistoriaExitoWhereInput | HistoriaExitoWhereInput[]
    id?: IntFilter<"HistoriaExito"> | number
    animalId?: IntFilter<"HistoriaExito"> | number
    titulo?: StringFilter<"HistoriaExito"> | string
    descripcion?: StringFilter<"HistoriaExito"> | string
    fecha?: DateTimeFilter<"HistoriaExito"> | Date | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
  }

  export type HistoriaExitoOrderByWithRelationInput = {
    id?: SortOrder
    animalId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    animal?: AnimalOrderByWithRelationInput
  }

  export type HistoriaExitoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistoriaExitoWhereInput | HistoriaExitoWhereInput[]
    OR?: HistoriaExitoWhereInput[]
    NOT?: HistoriaExitoWhereInput | HistoriaExitoWhereInput[]
    animalId?: IntFilter<"HistoriaExito"> | number
    titulo?: StringFilter<"HistoriaExito"> | string
    descripcion?: StringFilter<"HistoriaExito"> | string
    fecha?: DateTimeFilter<"HistoriaExito"> | Date | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
  }, "id">

  export type HistoriaExitoOrderByWithAggregationInput = {
    id?: SortOrder
    animalId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    _count?: HistoriaExitoCountOrderByAggregateInput
    _avg?: HistoriaExitoAvgOrderByAggregateInput
    _max?: HistoriaExitoMaxOrderByAggregateInput
    _min?: HistoriaExitoMinOrderByAggregateInput
    _sum?: HistoriaExitoSumOrderByAggregateInput
  }

  export type HistoriaExitoScalarWhereWithAggregatesInput = {
    AND?: HistoriaExitoScalarWhereWithAggregatesInput | HistoriaExitoScalarWhereWithAggregatesInput[]
    OR?: HistoriaExitoScalarWhereWithAggregatesInput[]
    NOT?: HistoriaExitoScalarWhereWithAggregatesInput | HistoriaExitoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HistoriaExito"> | number
    animalId?: IntWithAggregatesFilter<"HistoriaExito"> | number
    titulo?: StringWithAggregatesFilter<"HistoriaExito"> | string
    descripcion?: StringWithAggregatesFilter<"HistoriaExito"> | string
    fecha?: DateTimeWithAggregatesFilter<"HistoriaExito"> | Date | string
  }

  export type DonacionWhereInput = {
    AND?: DonacionWhereInput | DonacionWhereInput[]
    OR?: DonacionWhereInput[]
    NOT?: DonacionWhereInput | DonacionWhereInput[]
    id?: IntFilter<"Donacion"> | number
    usuarioId?: IntFilter<"Donacion"> | number
    monto?: FloatFilter<"Donacion"> | number
    fecha?: DateTimeFilter<"Donacion"> | Date | string
    tipo?: StringFilter<"Donacion"> | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type DonacionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type DonacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DonacionWhereInput | DonacionWhereInput[]
    OR?: DonacionWhereInput[]
    NOT?: DonacionWhereInput | DonacionWhereInput[]
    usuarioId?: IntFilter<"Donacion"> | number
    monto?: FloatFilter<"Donacion"> | number
    fecha?: DateTimeFilter<"Donacion"> | Date | string
    tipo?: StringFilter<"Donacion"> | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type DonacionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
    _count?: DonacionCountOrderByAggregateInput
    _avg?: DonacionAvgOrderByAggregateInput
    _max?: DonacionMaxOrderByAggregateInput
    _min?: DonacionMinOrderByAggregateInput
    _sum?: DonacionSumOrderByAggregateInput
  }

  export type DonacionScalarWhereWithAggregatesInput = {
    AND?: DonacionScalarWhereWithAggregatesInput | DonacionScalarWhereWithAggregatesInput[]
    OR?: DonacionScalarWhereWithAggregatesInput[]
    NOT?: DonacionScalarWhereWithAggregatesInput | DonacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Donacion"> | number
    usuarioId?: IntWithAggregatesFilter<"Donacion"> | number
    monto?: FloatWithAggregatesFilter<"Donacion"> | number
    fecha?: DateTimeWithAggregatesFilter<"Donacion"> | Date | string
    tipo?: StringWithAggregatesFilter<"Donacion"> | string
  }

  export type RegistroMedicoWhereInput = {
    AND?: RegistroMedicoWhereInput | RegistroMedicoWhereInput[]
    OR?: RegistroMedicoWhereInput[]
    NOT?: RegistroMedicoWhereInput | RegistroMedicoWhereInput[]
    id?: IntFilter<"RegistroMedico"> | number
    animalId?: IntFilter<"RegistroMedico"> | number
    veterinarioId?: IntFilter<"RegistroMedico"> | number
    descripcion?: StringFilter<"RegistroMedico"> | string
    fecha?: DateTimeFilter<"RegistroMedico"> | Date | string
    tipo?: StringFilter<"RegistroMedico"> | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
    veterinario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type RegistroMedicoOrderByWithRelationInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
    animal?: AnimalOrderByWithRelationInput
    veterinario?: UsuarioOrderByWithRelationInput
  }

  export type RegistroMedicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RegistroMedicoWhereInput | RegistroMedicoWhereInput[]
    OR?: RegistroMedicoWhereInput[]
    NOT?: RegistroMedicoWhereInput | RegistroMedicoWhereInput[]
    animalId?: IntFilter<"RegistroMedico"> | number
    veterinarioId?: IntFilter<"RegistroMedico"> | number
    descripcion?: StringFilter<"RegistroMedico"> | string
    fecha?: DateTimeFilter<"RegistroMedico"> | Date | string
    tipo?: StringFilter<"RegistroMedico"> | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
    veterinario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type RegistroMedicoOrderByWithAggregationInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
    _count?: RegistroMedicoCountOrderByAggregateInput
    _avg?: RegistroMedicoAvgOrderByAggregateInput
    _max?: RegistroMedicoMaxOrderByAggregateInput
    _min?: RegistroMedicoMinOrderByAggregateInput
    _sum?: RegistroMedicoSumOrderByAggregateInput
  }

  export type RegistroMedicoScalarWhereWithAggregatesInput = {
    AND?: RegistroMedicoScalarWhereWithAggregatesInput | RegistroMedicoScalarWhereWithAggregatesInput[]
    OR?: RegistroMedicoScalarWhereWithAggregatesInput[]
    NOT?: RegistroMedicoScalarWhereWithAggregatesInput | RegistroMedicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RegistroMedico"> | number
    animalId?: IntWithAggregatesFilter<"RegistroMedico"> | number
    veterinarioId?: IntWithAggregatesFilter<"RegistroMedico"> | number
    descripcion?: StringWithAggregatesFilter<"RegistroMedico"> | string
    fecha?: DateTimeWithAggregatesFilter<"RegistroMedico"> | Date | string
    tipo?: StringWithAggregatesFilter<"RegistroMedico"> | string
  }

  export type VoluntariadoWhereInput = {
    AND?: VoluntariadoWhereInput | VoluntariadoWhereInput[]
    OR?: VoluntariadoWhereInput[]
    NOT?: VoluntariadoWhereInput | VoluntariadoWhereInput[]
    id?: IntFilter<"Voluntariado"> | number
    usuarioId?: IntFilter<"Voluntariado"> | number
    actividad?: StringFilter<"Voluntariado"> | string
    fecha?: DateTimeFilter<"Voluntariado"> | Date | string
    estado?: StringFilter<"Voluntariado"> | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type VoluntariadoOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    actividad?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type VoluntariadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VoluntariadoWhereInput | VoluntariadoWhereInput[]
    OR?: VoluntariadoWhereInput[]
    NOT?: VoluntariadoWhereInput | VoluntariadoWhereInput[]
    usuarioId?: IntFilter<"Voluntariado"> | number
    actividad?: StringFilter<"Voluntariado"> | string
    fecha?: DateTimeFilter<"Voluntariado"> | Date | string
    estado?: StringFilter<"Voluntariado"> | string
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type VoluntariadoOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    actividad?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
    _count?: VoluntariadoCountOrderByAggregateInput
    _avg?: VoluntariadoAvgOrderByAggregateInput
    _max?: VoluntariadoMaxOrderByAggregateInput
    _min?: VoluntariadoMinOrderByAggregateInput
    _sum?: VoluntariadoSumOrderByAggregateInput
  }

  export type VoluntariadoScalarWhereWithAggregatesInput = {
    AND?: VoluntariadoScalarWhereWithAggregatesInput | VoluntariadoScalarWhereWithAggregatesInput[]
    OR?: VoluntariadoScalarWhereWithAggregatesInput[]
    NOT?: VoluntariadoScalarWhereWithAggregatesInput | VoluntariadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Voluntariado"> | number
    usuarioId?: IntWithAggregatesFilter<"Voluntariado"> | number
    actividad?: StringWithAggregatesFilter<"Voluntariado"> | string
    fecha?: DateTimeWithAggregatesFilter<"Voluntariado"> | Date | string
    estado?: StringWithAggregatesFilter<"Voluntariado"> | string
  }

  export type HogarTemporalWhereInput = {
    AND?: HogarTemporalWhereInput | HogarTemporalWhereInput[]
    OR?: HogarTemporalWhereInput[]
    NOT?: HogarTemporalWhereInput | HogarTemporalWhereInput[]
    id?: IntFilter<"HogarTemporal"> | number
    animalId?: IntFilter<"HogarTemporal"> | number
    usuarioId?: IntFilter<"HogarTemporal"> | number
    fechaInicio?: DateTimeFilter<"HogarTemporal"> | Date | string
    fechaFin?: DateTimeNullableFilter<"HogarTemporal"> | Date | string | null
    estado?: StringFilter<"HogarTemporal"> | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }

  export type HogarTemporalOrderByWithRelationInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    estado?: SortOrder
    animal?: AnimalOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type HogarTemporalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HogarTemporalWhereInput | HogarTemporalWhereInput[]
    OR?: HogarTemporalWhereInput[]
    NOT?: HogarTemporalWhereInput | HogarTemporalWhereInput[]
    animalId?: IntFilter<"HogarTemporal"> | number
    usuarioId?: IntFilter<"HogarTemporal"> | number
    fechaInicio?: DateTimeFilter<"HogarTemporal"> | Date | string
    fechaFin?: DateTimeNullableFilter<"HogarTemporal"> | Date | string | null
    estado?: StringFilter<"HogarTemporal"> | string
    animal?: XOR<AnimalScalarRelationFilter, AnimalWhereInput>
    usuario?: XOR<UsuarioScalarRelationFilter, UsuarioWhereInput>
  }, "id">

  export type HogarTemporalOrderByWithAggregationInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: HogarTemporalCountOrderByAggregateInput
    _avg?: HogarTemporalAvgOrderByAggregateInput
    _max?: HogarTemporalMaxOrderByAggregateInput
    _min?: HogarTemporalMinOrderByAggregateInput
    _sum?: HogarTemporalSumOrderByAggregateInput
  }

  export type HogarTemporalScalarWhereWithAggregatesInput = {
    AND?: HogarTemporalScalarWhereWithAggregatesInput | HogarTemporalScalarWhereWithAggregatesInput[]
    OR?: HogarTemporalScalarWhereWithAggregatesInput[]
    NOT?: HogarTemporalScalarWhereWithAggregatesInput | HogarTemporalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HogarTemporal"> | number
    animalId?: IntWithAggregatesFilter<"HogarTemporal"> | number
    usuarioId?: IntWithAggregatesFilter<"HogarTemporal"> | number
    fechaInicio?: DateTimeWithAggregatesFilter<"HogarTemporal"> | Date | string
    fechaFin?: DateTimeNullableWithAggregatesFilter<"HogarTemporal"> | Date | string | null
    estado?: StringWithAggregatesFilter<"HogarTemporal"> | string
  }

  export type UsuarioCreateInput = {
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionUncheckedCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoUncheckedCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUncheckedUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUncheckedUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUncheckedUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimalCreateInput = {
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionCreateNestedManyWithoutAnimalInput
    historias?: HistoriaExitoCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateInput = {
    id?: number
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutAnimalInput
    historias?: HistoriaExitoUncheckedCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUpdateManyWithoutAnimalNestedInput
    historias?: HistoriaExitoUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUncheckedUpdateManyWithoutAnimalNestedInput
    historias?: HistoriaExitoUncheckedUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalCreateManyInput = {
    id?: number
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
  }

  export type AnimalUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnimalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdopcionCreateInput = {
    fechaAdopcion?: Date | string
    estado: string
    animal: AnimalCreateNestedOneWithoutAdopcionesInput
    usuario: UsuarioCreateNestedOneWithoutAdopcionesInput
  }

  export type AdopcionUncheckedCreateInput = {
    id?: number
    animalId: number
    usuarioId: number
    fechaAdopcion?: Date | string
    estado: string
  }

  export type AdopcionUpdateInput = {
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    animal?: AnimalUpdateOneRequiredWithoutAdopcionesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutAdopcionesNestedInput
  }

  export type AdopcionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AdopcionCreateManyInput = {
    id?: number
    animalId: number
    usuarioId: number
    fechaAdopcion?: Date | string
    estado: string
  }

  export type AdopcionUpdateManyMutationInput = {
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AdopcionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HistoriaExitoCreateInput = {
    titulo: string
    descripcion: string
    fecha?: Date | string
    animal: AnimalCreateNestedOneWithoutHistoriasInput
  }

  export type HistoriaExitoUncheckedCreateInput = {
    id?: number
    animalId: number
    titulo: string
    descripcion: string
    fecha?: Date | string
  }

  export type HistoriaExitoUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    animal?: AnimalUpdateOneRequiredWithoutHistoriasNestedInput
  }

  export type HistoriaExitoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoriaExitoCreateManyInput = {
    id?: number
    animalId: number
    titulo: string
    descripcion: string
    fecha?: Date | string
  }

  export type HistoriaExitoUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoriaExitoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonacionCreateInput = {
    monto: number
    fecha?: Date | string
    tipo: string
    usuario: UsuarioCreateNestedOneWithoutDonacionesInput
  }

  export type DonacionUncheckedCreateInput = {
    id?: number
    usuarioId: number
    monto: number
    fecha?: Date | string
    tipo: string
  }

  export type DonacionUpdateInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutDonacionesNestedInput
  }

  export type DonacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type DonacionCreateManyInput = {
    id?: number
    usuarioId: number
    monto: number
    fecha?: Date | string
    tipo: string
  }

  export type DonacionUpdateManyMutationInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type DonacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroMedicoCreateInput = {
    descripcion: string
    fecha?: Date | string
    tipo: string
    animal: AnimalCreateNestedOneWithoutRegistrosMedicosInput
    veterinario: UsuarioCreateNestedOneWithoutRegistrosMedicosInput
  }

  export type RegistroMedicoUncheckedCreateInput = {
    id?: number
    animalId: number
    veterinarioId: number
    descripcion: string
    fecha?: Date | string
    tipo: string
  }

  export type RegistroMedicoUpdateInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    animal?: AnimalUpdateOneRequiredWithoutRegistrosMedicosNestedInput
    veterinario?: UsuarioUpdateOneRequiredWithoutRegistrosMedicosNestedInput
  }

  export type RegistroMedicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    veterinarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroMedicoCreateManyInput = {
    id?: number
    animalId: number
    veterinarioId: number
    descripcion: string
    fecha?: Date | string
    tipo: string
  }

  export type RegistroMedicoUpdateManyMutationInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroMedicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    veterinarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type VoluntariadoCreateInput = {
    actividad: string
    fecha?: Date | string
    estado: string
    usuario: UsuarioCreateNestedOneWithoutVoluntariadosInput
  }

  export type VoluntariadoUncheckedCreateInput = {
    id?: number
    usuarioId: number
    actividad: string
    fecha?: Date | string
    estado: string
  }

  export type VoluntariadoUpdateInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutVoluntariadosNestedInput
  }

  export type VoluntariadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type VoluntariadoCreateManyInput = {
    id?: number
    usuarioId: number
    actividad: string
    fecha?: Date | string
    estado: string
  }

  export type VoluntariadoUpdateManyMutationInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type VoluntariadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalCreateInput = {
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
    animal: AnimalCreateNestedOneWithoutHogaresTemporalesInput
    usuario: UsuarioCreateNestedOneWithoutHogaresTemporalesInput
  }

  export type HogarTemporalUncheckedCreateInput = {
    id?: number
    animalId: number
    usuarioId: number
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
  }

  export type HogarTemporalUpdateInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    animal?: AnimalUpdateOneRequiredWithoutHogaresTemporalesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutHogaresTemporalesNestedInput
  }

  export type HogarTemporalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalCreateManyInput = {
    id?: number
    animalId: number
    usuarioId: number
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
  }

  export type HogarTemporalUpdateManyMutationInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdopcionListRelationFilter = {
    every?: AdopcionWhereInput
    some?: AdopcionWhereInput
    none?: AdopcionWhereInput
  }

  export type DonacionListRelationFilter = {
    every?: DonacionWhereInput
    some?: DonacionWhereInput
    none?: DonacionWhereInput
  }

  export type VoluntariadoListRelationFilter = {
    every?: VoluntariadoWhereInput
    some?: VoluntariadoWhereInput
    none?: VoluntariadoWhereInput
  }

  export type RegistroMedicoListRelationFilter = {
    every?: RegistroMedicoWhereInput
    some?: RegistroMedicoWhereInput
    none?: RegistroMedicoWhereInput
  }

  export type HogarTemporalListRelationFilter = {
    every?: HogarTemporalWhereInput
    some?: HogarTemporalWhereInput
    none?: HogarTemporalWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdopcionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoluntariadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegistroMedicoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HogarTemporalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    tipoUsuario?: SortOrder
    estado?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    tipoUsuario?: SortOrder
    estado?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    tipoUsuario?: SortOrder
    estado?: SortOrder
    avatar?: SortOrder
    password?: SortOrder
    fechaRegistro?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type HistoriaExitoListRelationFilter = {
    every?: HistoriaExitoWhereInput
    some?: HistoriaExitoWhereInput
    none?: HistoriaExitoWhereInput
  }

  export type HistoriaExitoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnimalCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    especie?: SortOrder
    raza?: SortOrder
    edad?: SortOrder
    estado?: SortOrder
    fechaIngreso?: SortOrder
    descripcion?: SortOrder
    foto?: SortOrder
  }

  export type AnimalAvgOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type AnimalMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    especie?: SortOrder
    raza?: SortOrder
    edad?: SortOrder
    estado?: SortOrder
    fechaIngreso?: SortOrder
    descripcion?: SortOrder
    foto?: SortOrder
  }

  export type AnimalMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    especie?: SortOrder
    raza?: SortOrder
    edad?: SortOrder
    estado?: SortOrder
    fechaIngreso?: SortOrder
    descripcion?: SortOrder
    foto?: SortOrder
  }

  export type AnimalSumOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AnimalScalarRelationFilter = {
    is?: AnimalWhereInput
    isNot?: AnimalWhereInput
  }

  export type UsuarioScalarRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type AdopcionCountOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaAdopcion?: SortOrder
    estado?: SortOrder
  }

  export type AdopcionAvgOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
  }

  export type AdopcionMaxOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaAdopcion?: SortOrder
    estado?: SortOrder
  }

  export type AdopcionMinOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaAdopcion?: SortOrder
    estado?: SortOrder
  }

  export type AdopcionSumOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
  }

  export type HistoriaExitoCountOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
  }

  export type HistoriaExitoAvgOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
  }

  export type HistoriaExitoMaxOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
  }

  export type HistoriaExitoMinOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    titulo?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
  }

  export type HistoriaExitoSumOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DonacionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
  }

  export type DonacionAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
  }

  export type DonacionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
  }

  export type DonacionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
  }

  export type DonacionSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    monto?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RegistroMedicoCountOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
  }

  export type RegistroMedicoAvgOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
  }

  export type RegistroMedicoMaxOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
  }

  export type RegistroMedicoMinOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
    descripcion?: SortOrder
    fecha?: SortOrder
    tipo?: SortOrder
  }

  export type RegistroMedicoSumOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    veterinarioId?: SortOrder
  }

  export type VoluntariadoCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    actividad?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type VoluntariadoAvgOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type VoluntariadoMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    actividad?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type VoluntariadoMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    actividad?: SortOrder
    fecha?: SortOrder
    estado?: SortOrder
  }

  export type VoluntariadoSumOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type HogarTemporalCountOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
  }

  export type HogarTemporalAvgOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
  }

  export type HogarTemporalMaxOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
  }

  export type HogarTemporalMinOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    estado?: SortOrder
  }

  export type HogarTemporalSumOrderByAggregateInput = {
    id?: SortOrder
    animalId?: SortOrder
    usuarioId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AdopcionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AdopcionCreateWithoutUsuarioInput, AdopcionUncheckedCreateWithoutUsuarioInput> | AdopcionCreateWithoutUsuarioInput[] | AdopcionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutUsuarioInput | AdopcionCreateOrConnectWithoutUsuarioInput[]
    createMany?: AdopcionCreateManyUsuarioInputEnvelope
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
  }

  export type DonacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<DonacionCreateWithoutUsuarioInput, DonacionUncheckedCreateWithoutUsuarioInput> | DonacionCreateWithoutUsuarioInput[] | DonacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutUsuarioInput | DonacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: DonacionCreateManyUsuarioInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type VoluntariadoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<VoluntariadoCreateWithoutUsuarioInput, VoluntariadoUncheckedCreateWithoutUsuarioInput> | VoluntariadoCreateWithoutUsuarioInput[] | VoluntariadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: VoluntariadoCreateOrConnectWithoutUsuarioInput | VoluntariadoCreateOrConnectWithoutUsuarioInput[]
    createMany?: VoluntariadoCreateManyUsuarioInputEnvelope
    connect?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
  }

  export type RegistroMedicoCreateNestedManyWithoutVeterinarioInput = {
    create?: XOR<RegistroMedicoCreateWithoutVeterinarioInput, RegistroMedicoUncheckedCreateWithoutVeterinarioInput> | RegistroMedicoCreateWithoutVeterinarioInput[] | RegistroMedicoUncheckedCreateWithoutVeterinarioInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutVeterinarioInput | RegistroMedicoCreateOrConnectWithoutVeterinarioInput[]
    createMany?: RegistroMedicoCreateManyVeterinarioInputEnvelope
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
  }

  export type HogarTemporalCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<HogarTemporalCreateWithoutUsuarioInput, HogarTemporalUncheckedCreateWithoutUsuarioInput> | HogarTemporalCreateWithoutUsuarioInput[] | HogarTemporalUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutUsuarioInput | HogarTemporalCreateOrConnectWithoutUsuarioInput[]
    createMany?: HogarTemporalCreateManyUsuarioInputEnvelope
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
  }

  export type AdopcionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<AdopcionCreateWithoutUsuarioInput, AdopcionUncheckedCreateWithoutUsuarioInput> | AdopcionCreateWithoutUsuarioInput[] | AdopcionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutUsuarioInput | AdopcionCreateOrConnectWithoutUsuarioInput[]
    createMany?: AdopcionCreateManyUsuarioInputEnvelope
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
  }

  export type DonacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<DonacionCreateWithoutUsuarioInput, DonacionUncheckedCreateWithoutUsuarioInput> | DonacionCreateWithoutUsuarioInput[] | DonacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutUsuarioInput | DonacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: DonacionCreateManyUsuarioInputEnvelope
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
  }

  export type VoluntariadoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<VoluntariadoCreateWithoutUsuarioInput, VoluntariadoUncheckedCreateWithoutUsuarioInput> | VoluntariadoCreateWithoutUsuarioInput[] | VoluntariadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: VoluntariadoCreateOrConnectWithoutUsuarioInput | VoluntariadoCreateOrConnectWithoutUsuarioInput[]
    createMany?: VoluntariadoCreateManyUsuarioInputEnvelope
    connect?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
  }

  export type RegistroMedicoUncheckedCreateNestedManyWithoutVeterinarioInput = {
    create?: XOR<RegistroMedicoCreateWithoutVeterinarioInput, RegistroMedicoUncheckedCreateWithoutVeterinarioInput> | RegistroMedicoCreateWithoutVeterinarioInput[] | RegistroMedicoUncheckedCreateWithoutVeterinarioInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutVeterinarioInput | RegistroMedicoCreateOrConnectWithoutVeterinarioInput[]
    createMany?: RegistroMedicoCreateManyVeterinarioInputEnvelope
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
  }

  export type HogarTemporalUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<HogarTemporalCreateWithoutUsuarioInput, HogarTemporalUncheckedCreateWithoutUsuarioInput> | HogarTemporalCreateWithoutUsuarioInput[] | HogarTemporalUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutUsuarioInput | HogarTemporalCreateOrConnectWithoutUsuarioInput[]
    createMany?: HogarTemporalCreateManyUsuarioInputEnvelope
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdopcionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AdopcionCreateWithoutUsuarioInput, AdopcionUncheckedCreateWithoutUsuarioInput> | AdopcionCreateWithoutUsuarioInput[] | AdopcionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutUsuarioInput | AdopcionCreateOrConnectWithoutUsuarioInput[]
    upsert?: AdopcionUpsertWithWhereUniqueWithoutUsuarioInput | AdopcionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AdopcionCreateManyUsuarioInputEnvelope
    set?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    disconnect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    delete?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    update?: AdopcionUpdateWithWhereUniqueWithoutUsuarioInput | AdopcionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AdopcionUpdateManyWithWhereWithoutUsuarioInput | AdopcionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AdopcionScalarWhereInput | AdopcionScalarWhereInput[]
  }

  export type DonacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<DonacionCreateWithoutUsuarioInput, DonacionUncheckedCreateWithoutUsuarioInput> | DonacionCreateWithoutUsuarioInput[] | DonacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutUsuarioInput | DonacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutUsuarioInput | DonacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: DonacionCreateManyUsuarioInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutUsuarioInput | DonacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutUsuarioInput | DonacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type VoluntariadoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<VoluntariadoCreateWithoutUsuarioInput, VoluntariadoUncheckedCreateWithoutUsuarioInput> | VoluntariadoCreateWithoutUsuarioInput[] | VoluntariadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: VoluntariadoCreateOrConnectWithoutUsuarioInput | VoluntariadoCreateOrConnectWithoutUsuarioInput[]
    upsert?: VoluntariadoUpsertWithWhereUniqueWithoutUsuarioInput | VoluntariadoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: VoluntariadoCreateManyUsuarioInputEnvelope
    set?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    disconnect?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    delete?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    connect?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    update?: VoluntariadoUpdateWithWhereUniqueWithoutUsuarioInput | VoluntariadoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: VoluntariadoUpdateManyWithWhereWithoutUsuarioInput | VoluntariadoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: VoluntariadoScalarWhereInput | VoluntariadoScalarWhereInput[]
  }

  export type RegistroMedicoUpdateManyWithoutVeterinarioNestedInput = {
    create?: XOR<RegistroMedicoCreateWithoutVeterinarioInput, RegistroMedicoUncheckedCreateWithoutVeterinarioInput> | RegistroMedicoCreateWithoutVeterinarioInput[] | RegistroMedicoUncheckedCreateWithoutVeterinarioInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutVeterinarioInput | RegistroMedicoCreateOrConnectWithoutVeterinarioInput[]
    upsert?: RegistroMedicoUpsertWithWhereUniqueWithoutVeterinarioInput | RegistroMedicoUpsertWithWhereUniqueWithoutVeterinarioInput[]
    createMany?: RegistroMedicoCreateManyVeterinarioInputEnvelope
    set?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    disconnect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    delete?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    update?: RegistroMedicoUpdateWithWhereUniqueWithoutVeterinarioInput | RegistroMedicoUpdateWithWhereUniqueWithoutVeterinarioInput[]
    updateMany?: RegistroMedicoUpdateManyWithWhereWithoutVeterinarioInput | RegistroMedicoUpdateManyWithWhereWithoutVeterinarioInput[]
    deleteMany?: RegistroMedicoScalarWhereInput | RegistroMedicoScalarWhereInput[]
  }

  export type HogarTemporalUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<HogarTemporalCreateWithoutUsuarioInput, HogarTemporalUncheckedCreateWithoutUsuarioInput> | HogarTemporalCreateWithoutUsuarioInput[] | HogarTemporalUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutUsuarioInput | HogarTemporalCreateOrConnectWithoutUsuarioInput[]
    upsert?: HogarTemporalUpsertWithWhereUniqueWithoutUsuarioInput | HogarTemporalUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: HogarTemporalCreateManyUsuarioInputEnvelope
    set?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    disconnect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    delete?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    update?: HogarTemporalUpdateWithWhereUniqueWithoutUsuarioInput | HogarTemporalUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: HogarTemporalUpdateManyWithWhereWithoutUsuarioInput | HogarTemporalUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: HogarTemporalScalarWhereInput | HogarTemporalScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdopcionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<AdopcionCreateWithoutUsuarioInput, AdopcionUncheckedCreateWithoutUsuarioInput> | AdopcionCreateWithoutUsuarioInput[] | AdopcionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutUsuarioInput | AdopcionCreateOrConnectWithoutUsuarioInput[]
    upsert?: AdopcionUpsertWithWhereUniqueWithoutUsuarioInput | AdopcionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: AdopcionCreateManyUsuarioInputEnvelope
    set?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    disconnect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    delete?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    update?: AdopcionUpdateWithWhereUniqueWithoutUsuarioInput | AdopcionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: AdopcionUpdateManyWithWhereWithoutUsuarioInput | AdopcionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: AdopcionScalarWhereInput | AdopcionScalarWhereInput[]
  }

  export type DonacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<DonacionCreateWithoutUsuarioInput, DonacionUncheckedCreateWithoutUsuarioInput> | DonacionCreateWithoutUsuarioInput[] | DonacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DonacionCreateOrConnectWithoutUsuarioInput | DonacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: DonacionUpsertWithWhereUniqueWithoutUsuarioInput | DonacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: DonacionCreateManyUsuarioInputEnvelope
    set?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    disconnect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    delete?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    connect?: DonacionWhereUniqueInput | DonacionWhereUniqueInput[]
    update?: DonacionUpdateWithWhereUniqueWithoutUsuarioInput | DonacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: DonacionUpdateManyWithWhereWithoutUsuarioInput | DonacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
  }

  export type VoluntariadoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<VoluntariadoCreateWithoutUsuarioInput, VoluntariadoUncheckedCreateWithoutUsuarioInput> | VoluntariadoCreateWithoutUsuarioInput[] | VoluntariadoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: VoluntariadoCreateOrConnectWithoutUsuarioInput | VoluntariadoCreateOrConnectWithoutUsuarioInput[]
    upsert?: VoluntariadoUpsertWithWhereUniqueWithoutUsuarioInput | VoluntariadoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: VoluntariadoCreateManyUsuarioInputEnvelope
    set?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    disconnect?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    delete?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    connect?: VoluntariadoWhereUniqueInput | VoluntariadoWhereUniqueInput[]
    update?: VoluntariadoUpdateWithWhereUniqueWithoutUsuarioInput | VoluntariadoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: VoluntariadoUpdateManyWithWhereWithoutUsuarioInput | VoluntariadoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: VoluntariadoScalarWhereInput | VoluntariadoScalarWhereInput[]
  }

  export type RegistroMedicoUncheckedUpdateManyWithoutVeterinarioNestedInput = {
    create?: XOR<RegistroMedicoCreateWithoutVeterinarioInput, RegistroMedicoUncheckedCreateWithoutVeterinarioInput> | RegistroMedicoCreateWithoutVeterinarioInput[] | RegistroMedicoUncheckedCreateWithoutVeterinarioInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutVeterinarioInput | RegistroMedicoCreateOrConnectWithoutVeterinarioInput[]
    upsert?: RegistroMedicoUpsertWithWhereUniqueWithoutVeterinarioInput | RegistroMedicoUpsertWithWhereUniqueWithoutVeterinarioInput[]
    createMany?: RegistroMedicoCreateManyVeterinarioInputEnvelope
    set?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    disconnect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    delete?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    update?: RegistroMedicoUpdateWithWhereUniqueWithoutVeterinarioInput | RegistroMedicoUpdateWithWhereUniqueWithoutVeterinarioInput[]
    updateMany?: RegistroMedicoUpdateManyWithWhereWithoutVeterinarioInput | RegistroMedicoUpdateManyWithWhereWithoutVeterinarioInput[]
    deleteMany?: RegistroMedicoScalarWhereInput | RegistroMedicoScalarWhereInput[]
  }

  export type HogarTemporalUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<HogarTemporalCreateWithoutUsuarioInput, HogarTemporalUncheckedCreateWithoutUsuarioInput> | HogarTemporalCreateWithoutUsuarioInput[] | HogarTemporalUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutUsuarioInput | HogarTemporalCreateOrConnectWithoutUsuarioInput[]
    upsert?: HogarTemporalUpsertWithWhereUniqueWithoutUsuarioInput | HogarTemporalUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: HogarTemporalCreateManyUsuarioInputEnvelope
    set?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    disconnect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    delete?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    update?: HogarTemporalUpdateWithWhereUniqueWithoutUsuarioInput | HogarTemporalUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: HogarTemporalUpdateManyWithWhereWithoutUsuarioInput | HogarTemporalUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: HogarTemporalScalarWhereInput | HogarTemporalScalarWhereInput[]
  }

  export type AdopcionCreateNestedManyWithoutAnimalInput = {
    create?: XOR<AdopcionCreateWithoutAnimalInput, AdopcionUncheckedCreateWithoutAnimalInput> | AdopcionCreateWithoutAnimalInput[] | AdopcionUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutAnimalInput | AdopcionCreateOrConnectWithoutAnimalInput[]
    createMany?: AdopcionCreateManyAnimalInputEnvelope
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
  }

  export type HistoriaExitoCreateNestedManyWithoutAnimalInput = {
    create?: XOR<HistoriaExitoCreateWithoutAnimalInput, HistoriaExitoUncheckedCreateWithoutAnimalInput> | HistoriaExitoCreateWithoutAnimalInput[] | HistoriaExitoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HistoriaExitoCreateOrConnectWithoutAnimalInput | HistoriaExitoCreateOrConnectWithoutAnimalInput[]
    createMany?: HistoriaExitoCreateManyAnimalInputEnvelope
    connect?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
  }

  export type RegistroMedicoCreateNestedManyWithoutAnimalInput = {
    create?: XOR<RegistroMedicoCreateWithoutAnimalInput, RegistroMedicoUncheckedCreateWithoutAnimalInput> | RegistroMedicoCreateWithoutAnimalInput[] | RegistroMedicoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutAnimalInput | RegistroMedicoCreateOrConnectWithoutAnimalInput[]
    createMany?: RegistroMedicoCreateManyAnimalInputEnvelope
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
  }

  export type HogarTemporalCreateNestedManyWithoutAnimalInput = {
    create?: XOR<HogarTemporalCreateWithoutAnimalInput, HogarTemporalUncheckedCreateWithoutAnimalInput> | HogarTemporalCreateWithoutAnimalInput[] | HogarTemporalUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutAnimalInput | HogarTemporalCreateOrConnectWithoutAnimalInput[]
    createMany?: HogarTemporalCreateManyAnimalInputEnvelope
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
  }

  export type AdopcionUncheckedCreateNestedManyWithoutAnimalInput = {
    create?: XOR<AdopcionCreateWithoutAnimalInput, AdopcionUncheckedCreateWithoutAnimalInput> | AdopcionCreateWithoutAnimalInput[] | AdopcionUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutAnimalInput | AdopcionCreateOrConnectWithoutAnimalInput[]
    createMany?: AdopcionCreateManyAnimalInputEnvelope
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
  }

  export type HistoriaExitoUncheckedCreateNestedManyWithoutAnimalInput = {
    create?: XOR<HistoriaExitoCreateWithoutAnimalInput, HistoriaExitoUncheckedCreateWithoutAnimalInput> | HistoriaExitoCreateWithoutAnimalInput[] | HistoriaExitoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HistoriaExitoCreateOrConnectWithoutAnimalInput | HistoriaExitoCreateOrConnectWithoutAnimalInput[]
    createMany?: HistoriaExitoCreateManyAnimalInputEnvelope
    connect?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
  }

  export type RegistroMedicoUncheckedCreateNestedManyWithoutAnimalInput = {
    create?: XOR<RegistroMedicoCreateWithoutAnimalInput, RegistroMedicoUncheckedCreateWithoutAnimalInput> | RegistroMedicoCreateWithoutAnimalInput[] | RegistroMedicoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutAnimalInput | RegistroMedicoCreateOrConnectWithoutAnimalInput[]
    createMany?: RegistroMedicoCreateManyAnimalInputEnvelope
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
  }

  export type HogarTemporalUncheckedCreateNestedManyWithoutAnimalInput = {
    create?: XOR<HogarTemporalCreateWithoutAnimalInput, HogarTemporalUncheckedCreateWithoutAnimalInput> | HogarTemporalCreateWithoutAnimalInput[] | HogarTemporalUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutAnimalInput | HogarTemporalCreateOrConnectWithoutAnimalInput[]
    createMany?: HogarTemporalCreateManyAnimalInputEnvelope
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdopcionUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<AdopcionCreateWithoutAnimalInput, AdopcionUncheckedCreateWithoutAnimalInput> | AdopcionCreateWithoutAnimalInput[] | AdopcionUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutAnimalInput | AdopcionCreateOrConnectWithoutAnimalInput[]
    upsert?: AdopcionUpsertWithWhereUniqueWithoutAnimalInput | AdopcionUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: AdopcionCreateManyAnimalInputEnvelope
    set?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    disconnect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    delete?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    update?: AdopcionUpdateWithWhereUniqueWithoutAnimalInput | AdopcionUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: AdopcionUpdateManyWithWhereWithoutAnimalInput | AdopcionUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: AdopcionScalarWhereInput | AdopcionScalarWhereInput[]
  }

  export type HistoriaExitoUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<HistoriaExitoCreateWithoutAnimalInput, HistoriaExitoUncheckedCreateWithoutAnimalInput> | HistoriaExitoCreateWithoutAnimalInput[] | HistoriaExitoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HistoriaExitoCreateOrConnectWithoutAnimalInput | HistoriaExitoCreateOrConnectWithoutAnimalInput[]
    upsert?: HistoriaExitoUpsertWithWhereUniqueWithoutAnimalInput | HistoriaExitoUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: HistoriaExitoCreateManyAnimalInputEnvelope
    set?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    disconnect?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    delete?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    connect?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    update?: HistoriaExitoUpdateWithWhereUniqueWithoutAnimalInput | HistoriaExitoUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: HistoriaExitoUpdateManyWithWhereWithoutAnimalInput | HistoriaExitoUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: HistoriaExitoScalarWhereInput | HistoriaExitoScalarWhereInput[]
  }

  export type RegistroMedicoUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<RegistroMedicoCreateWithoutAnimalInput, RegistroMedicoUncheckedCreateWithoutAnimalInput> | RegistroMedicoCreateWithoutAnimalInput[] | RegistroMedicoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutAnimalInput | RegistroMedicoCreateOrConnectWithoutAnimalInput[]
    upsert?: RegistroMedicoUpsertWithWhereUniqueWithoutAnimalInput | RegistroMedicoUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: RegistroMedicoCreateManyAnimalInputEnvelope
    set?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    disconnect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    delete?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    update?: RegistroMedicoUpdateWithWhereUniqueWithoutAnimalInput | RegistroMedicoUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: RegistroMedicoUpdateManyWithWhereWithoutAnimalInput | RegistroMedicoUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: RegistroMedicoScalarWhereInput | RegistroMedicoScalarWhereInput[]
  }

  export type HogarTemporalUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<HogarTemporalCreateWithoutAnimalInput, HogarTemporalUncheckedCreateWithoutAnimalInput> | HogarTemporalCreateWithoutAnimalInput[] | HogarTemporalUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutAnimalInput | HogarTemporalCreateOrConnectWithoutAnimalInput[]
    upsert?: HogarTemporalUpsertWithWhereUniqueWithoutAnimalInput | HogarTemporalUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: HogarTemporalCreateManyAnimalInputEnvelope
    set?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    disconnect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    delete?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    update?: HogarTemporalUpdateWithWhereUniqueWithoutAnimalInput | HogarTemporalUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: HogarTemporalUpdateManyWithWhereWithoutAnimalInput | HogarTemporalUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: HogarTemporalScalarWhereInput | HogarTemporalScalarWhereInput[]
  }

  export type AdopcionUncheckedUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<AdopcionCreateWithoutAnimalInput, AdopcionUncheckedCreateWithoutAnimalInput> | AdopcionCreateWithoutAnimalInput[] | AdopcionUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: AdopcionCreateOrConnectWithoutAnimalInput | AdopcionCreateOrConnectWithoutAnimalInput[]
    upsert?: AdopcionUpsertWithWhereUniqueWithoutAnimalInput | AdopcionUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: AdopcionCreateManyAnimalInputEnvelope
    set?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    disconnect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    delete?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    connect?: AdopcionWhereUniqueInput | AdopcionWhereUniqueInput[]
    update?: AdopcionUpdateWithWhereUniqueWithoutAnimalInput | AdopcionUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: AdopcionUpdateManyWithWhereWithoutAnimalInput | AdopcionUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: AdopcionScalarWhereInput | AdopcionScalarWhereInput[]
  }

  export type HistoriaExitoUncheckedUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<HistoriaExitoCreateWithoutAnimalInput, HistoriaExitoUncheckedCreateWithoutAnimalInput> | HistoriaExitoCreateWithoutAnimalInput[] | HistoriaExitoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HistoriaExitoCreateOrConnectWithoutAnimalInput | HistoriaExitoCreateOrConnectWithoutAnimalInput[]
    upsert?: HistoriaExitoUpsertWithWhereUniqueWithoutAnimalInput | HistoriaExitoUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: HistoriaExitoCreateManyAnimalInputEnvelope
    set?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    disconnect?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    delete?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    connect?: HistoriaExitoWhereUniqueInput | HistoriaExitoWhereUniqueInput[]
    update?: HistoriaExitoUpdateWithWhereUniqueWithoutAnimalInput | HistoriaExitoUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: HistoriaExitoUpdateManyWithWhereWithoutAnimalInput | HistoriaExitoUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: HistoriaExitoScalarWhereInput | HistoriaExitoScalarWhereInput[]
  }

  export type RegistroMedicoUncheckedUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<RegistroMedicoCreateWithoutAnimalInput, RegistroMedicoUncheckedCreateWithoutAnimalInput> | RegistroMedicoCreateWithoutAnimalInput[] | RegistroMedicoUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: RegistroMedicoCreateOrConnectWithoutAnimalInput | RegistroMedicoCreateOrConnectWithoutAnimalInput[]
    upsert?: RegistroMedicoUpsertWithWhereUniqueWithoutAnimalInput | RegistroMedicoUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: RegistroMedicoCreateManyAnimalInputEnvelope
    set?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    disconnect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    delete?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    connect?: RegistroMedicoWhereUniqueInput | RegistroMedicoWhereUniqueInput[]
    update?: RegistroMedicoUpdateWithWhereUniqueWithoutAnimalInput | RegistroMedicoUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: RegistroMedicoUpdateManyWithWhereWithoutAnimalInput | RegistroMedicoUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: RegistroMedicoScalarWhereInput | RegistroMedicoScalarWhereInput[]
  }

  export type HogarTemporalUncheckedUpdateManyWithoutAnimalNestedInput = {
    create?: XOR<HogarTemporalCreateWithoutAnimalInput, HogarTemporalUncheckedCreateWithoutAnimalInput> | HogarTemporalCreateWithoutAnimalInput[] | HogarTemporalUncheckedCreateWithoutAnimalInput[]
    connectOrCreate?: HogarTemporalCreateOrConnectWithoutAnimalInput | HogarTemporalCreateOrConnectWithoutAnimalInput[]
    upsert?: HogarTemporalUpsertWithWhereUniqueWithoutAnimalInput | HogarTemporalUpsertWithWhereUniqueWithoutAnimalInput[]
    createMany?: HogarTemporalCreateManyAnimalInputEnvelope
    set?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    disconnect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    delete?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    connect?: HogarTemporalWhereUniqueInput | HogarTemporalWhereUniqueInput[]
    update?: HogarTemporalUpdateWithWhereUniqueWithoutAnimalInput | HogarTemporalUpdateWithWhereUniqueWithoutAnimalInput[]
    updateMany?: HogarTemporalUpdateManyWithWhereWithoutAnimalInput | HogarTemporalUpdateManyWithWhereWithoutAnimalInput[]
    deleteMany?: HogarTemporalScalarWhereInput | HogarTemporalScalarWhereInput[]
  }

  export type AnimalCreateNestedOneWithoutAdopcionesInput = {
    create?: XOR<AnimalCreateWithoutAdopcionesInput, AnimalUncheckedCreateWithoutAdopcionesInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutAdopcionesInput
    connect?: AnimalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutAdopcionesInput = {
    create?: XOR<UsuarioCreateWithoutAdopcionesInput, UsuarioUncheckedCreateWithoutAdopcionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAdopcionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type AnimalUpdateOneRequiredWithoutAdopcionesNestedInput = {
    create?: XOR<AnimalCreateWithoutAdopcionesInput, AnimalUncheckedCreateWithoutAdopcionesInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutAdopcionesInput
    upsert?: AnimalUpsertWithoutAdopcionesInput
    connect?: AnimalWhereUniqueInput
    update?: XOR<XOR<AnimalUpdateToOneWithWhereWithoutAdopcionesInput, AnimalUpdateWithoutAdopcionesInput>, AnimalUncheckedUpdateWithoutAdopcionesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutAdopcionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutAdopcionesInput, UsuarioUncheckedCreateWithoutAdopcionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAdopcionesInput
    upsert?: UsuarioUpsertWithoutAdopcionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAdopcionesInput, UsuarioUpdateWithoutAdopcionesInput>, UsuarioUncheckedUpdateWithoutAdopcionesInput>
  }

  export type AnimalCreateNestedOneWithoutHistoriasInput = {
    create?: XOR<AnimalCreateWithoutHistoriasInput, AnimalUncheckedCreateWithoutHistoriasInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutHistoriasInput
    connect?: AnimalWhereUniqueInput
  }

  export type AnimalUpdateOneRequiredWithoutHistoriasNestedInput = {
    create?: XOR<AnimalCreateWithoutHistoriasInput, AnimalUncheckedCreateWithoutHistoriasInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutHistoriasInput
    upsert?: AnimalUpsertWithoutHistoriasInput
    connect?: AnimalWhereUniqueInput
    update?: XOR<XOR<AnimalUpdateToOneWithWhereWithoutHistoriasInput, AnimalUpdateWithoutHistoriasInput>, AnimalUncheckedUpdateWithoutHistoriasInput>
  }

  export type UsuarioCreateNestedOneWithoutDonacionesInput = {
    create?: XOR<UsuarioCreateWithoutDonacionesInput, UsuarioUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDonacionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsuarioUpdateOneRequiredWithoutDonacionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutDonacionesInput, UsuarioUncheckedCreateWithoutDonacionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDonacionesInput
    upsert?: UsuarioUpsertWithoutDonacionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutDonacionesInput, UsuarioUpdateWithoutDonacionesInput>, UsuarioUncheckedUpdateWithoutDonacionesInput>
  }

  export type AnimalCreateNestedOneWithoutRegistrosMedicosInput = {
    create?: XOR<AnimalCreateWithoutRegistrosMedicosInput, AnimalUncheckedCreateWithoutRegistrosMedicosInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutRegistrosMedicosInput
    connect?: AnimalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutRegistrosMedicosInput = {
    create?: XOR<UsuarioCreateWithoutRegistrosMedicosInput, UsuarioUncheckedCreateWithoutRegistrosMedicosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRegistrosMedicosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type AnimalUpdateOneRequiredWithoutRegistrosMedicosNestedInput = {
    create?: XOR<AnimalCreateWithoutRegistrosMedicosInput, AnimalUncheckedCreateWithoutRegistrosMedicosInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutRegistrosMedicosInput
    upsert?: AnimalUpsertWithoutRegistrosMedicosInput
    connect?: AnimalWhereUniqueInput
    update?: XOR<XOR<AnimalUpdateToOneWithWhereWithoutRegistrosMedicosInput, AnimalUpdateWithoutRegistrosMedicosInput>, AnimalUncheckedUpdateWithoutRegistrosMedicosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutRegistrosMedicosNestedInput = {
    create?: XOR<UsuarioCreateWithoutRegistrosMedicosInput, UsuarioUncheckedCreateWithoutRegistrosMedicosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutRegistrosMedicosInput
    upsert?: UsuarioUpsertWithoutRegistrosMedicosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutRegistrosMedicosInput, UsuarioUpdateWithoutRegistrosMedicosInput>, UsuarioUncheckedUpdateWithoutRegistrosMedicosInput>
  }

  export type UsuarioCreateNestedOneWithoutVoluntariadosInput = {
    create?: XOR<UsuarioCreateWithoutVoluntariadosInput, UsuarioUncheckedCreateWithoutVoluntariadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutVoluntariadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutVoluntariadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutVoluntariadosInput, UsuarioUncheckedCreateWithoutVoluntariadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutVoluntariadosInput
    upsert?: UsuarioUpsertWithoutVoluntariadosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutVoluntariadosInput, UsuarioUpdateWithoutVoluntariadosInput>, UsuarioUncheckedUpdateWithoutVoluntariadosInput>
  }

  export type AnimalCreateNestedOneWithoutHogaresTemporalesInput = {
    create?: XOR<AnimalCreateWithoutHogaresTemporalesInput, AnimalUncheckedCreateWithoutHogaresTemporalesInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutHogaresTemporalesInput
    connect?: AnimalWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutHogaresTemporalesInput = {
    create?: XOR<UsuarioCreateWithoutHogaresTemporalesInput, UsuarioUncheckedCreateWithoutHogaresTemporalesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHogaresTemporalesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AnimalUpdateOneRequiredWithoutHogaresTemporalesNestedInput = {
    create?: XOR<AnimalCreateWithoutHogaresTemporalesInput, AnimalUncheckedCreateWithoutHogaresTemporalesInput>
    connectOrCreate?: AnimalCreateOrConnectWithoutHogaresTemporalesInput
    upsert?: AnimalUpsertWithoutHogaresTemporalesInput
    connect?: AnimalWhereUniqueInput
    update?: XOR<XOR<AnimalUpdateToOneWithWhereWithoutHogaresTemporalesInput, AnimalUpdateWithoutHogaresTemporalesInput>, AnimalUncheckedUpdateWithoutHogaresTemporalesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutHogaresTemporalesNestedInput = {
    create?: XOR<UsuarioCreateWithoutHogaresTemporalesInput, UsuarioUncheckedCreateWithoutHogaresTemporalesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutHogaresTemporalesInput
    upsert?: UsuarioUpsertWithoutHogaresTemporalesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutHogaresTemporalesInput, UsuarioUpdateWithoutHogaresTemporalesInput>, UsuarioUncheckedUpdateWithoutHogaresTemporalesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AdopcionCreateWithoutUsuarioInput = {
    fechaAdopcion?: Date | string
    estado: string
    animal: AnimalCreateNestedOneWithoutAdopcionesInput
  }

  export type AdopcionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    animalId: number
    fechaAdopcion?: Date | string
    estado: string
  }

  export type AdopcionCreateOrConnectWithoutUsuarioInput = {
    where: AdopcionWhereUniqueInput
    create: XOR<AdopcionCreateWithoutUsuarioInput, AdopcionUncheckedCreateWithoutUsuarioInput>
  }

  export type AdopcionCreateManyUsuarioInputEnvelope = {
    data: AdopcionCreateManyUsuarioInput | AdopcionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type DonacionCreateWithoutUsuarioInput = {
    monto: number
    fecha?: Date | string
    tipo: string
  }

  export type DonacionUncheckedCreateWithoutUsuarioInput = {
    id?: number
    monto: number
    fecha?: Date | string
    tipo: string
  }

  export type DonacionCreateOrConnectWithoutUsuarioInput = {
    where: DonacionWhereUniqueInput
    create: XOR<DonacionCreateWithoutUsuarioInput, DonacionUncheckedCreateWithoutUsuarioInput>
  }

  export type DonacionCreateManyUsuarioInputEnvelope = {
    data: DonacionCreateManyUsuarioInput | DonacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type VoluntariadoCreateWithoutUsuarioInput = {
    actividad: string
    fecha?: Date | string
    estado: string
  }

  export type VoluntariadoUncheckedCreateWithoutUsuarioInput = {
    id?: number
    actividad: string
    fecha?: Date | string
    estado: string
  }

  export type VoluntariadoCreateOrConnectWithoutUsuarioInput = {
    where: VoluntariadoWhereUniqueInput
    create: XOR<VoluntariadoCreateWithoutUsuarioInput, VoluntariadoUncheckedCreateWithoutUsuarioInput>
  }

  export type VoluntariadoCreateManyUsuarioInputEnvelope = {
    data: VoluntariadoCreateManyUsuarioInput | VoluntariadoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type RegistroMedicoCreateWithoutVeterinarioInput = {
    descripcion: string
    fecha?: Date | string
    tipo: string
    animal: AnimalCreateNestedOneWithoutRegistrosMedicosInput
  }

  export type RegistroMedicoUncheckedCreateWithoutVeterinarioInput = {
    id?: number
    animalId: number
    descripcion: string
    fecha?: Date | string
    tipo: string
  }

  export type RegistroMedicoCreateOrConnectWithoutVeterinarioInput = {
    where: RegistroMedicoWhereUniqueInput
    create: XOR<RegistroMedicoCreateWithoutVeterinarioInput, RegistroMedicoUncheckedCreateWithoutVeterinarioInput>
  }

  export type RegistroMedicoCreateManyVeterinarioInputEnvelope = {
    data: RegistroMedicoCreateManyVeterinarioInput | RegistroMedicoCreateManyVeterinarioInput[]
    skipDuplicates?: boolean
  }

  export type HogarTemporalCreateWithoutUsuarioInput = {
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
    animal: AnimalCreateNestedOneWithoutHogaresTemporalesInput
  }

  export type HogarTemporalUncheckedCreateWithoutUsuarioInput = {
    id?: number
    animalId: number
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
  }

  export type HogarTemporalCreateOrConnectWithoutUsuarioInput = {
    where: HogarTemporalWhereUniqueInput
    create: XOR<HogarTemporalCreateWithoutUsuarioInput, HogarTemporalUncheckedCreateWithoutUsuarioInput>
  }

  export type HogarTemporalCreateManyUsuarioInputEnvelope = {
    data: HogarTemporalCreateManyUsuarioInput | HogarTemporalCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type AdopcionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: AdopcionWhereUniqueInput
    update: XOR<AdopcionUpdateWithoutUsuarioInput, AdopcionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AdopcionCreateWithoutUsuarioInput, AdopcionUncheckedCreateWithoutUsuarioInput>
  }

  export type AdopcionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: AdopcionWhereUniqueInput
    data: XOR<AdopcionUpdateWithoutUsuarioInput, AdopcionUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdopcionUpdateManyWithWhereWithoutUsuarioInput = {
    where: AdopcionScalarWhereInput
    data: XOR<AdopcionUpdateManyMutationInput, AdopcionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type AdopcionScalarWhereInput = {
    AND?: AdopcionScalarWhereInput | AdopcionScalarWhereInput[]
    OR?: AdopcionScalarWhereInput[]
    NOT?: AdopcionScalarWhereInput | AdopcionScalarWhereInput[]
    id?: IntFilter<"Adopcion"> | number
    animalId?: IntFilter<"Adopcion"> | number
    usuarioId?: IntFilter<"Adopcion"> | number
    fechaAdopcion?: DateTimeFilter<"Adopcion"> | Date | string
    estado?: StringFilter<"Adopcion"> | string
  }

  export type DonacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: DonacionWhereUniqueInput
    update: XOR<DonacionUpdateWithoutUsuarioInput, DonacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<DonacionCreateWithoutUsuarioInput, DonacionUncheckedCreateWithoutUsuarioInput>
  }

  export type DonacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: DonacionWhereUniqueInput
    data: XOR<DonacionUpdateWithoutUsuarioInput, DonacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type DonacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: DonacionScalarWhereInput
    data: XOR<DonacionUpdateManyMutationInput, DonacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type DonacionScalarWhereInput = {
    AND?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
    OR?: DonacionScalarWhereInput[]
    NOT?: DonacionScalarWhereInput | DonacionScalarWhereInput[]
    id?: IntFilter<"Donacion"> | number
    usuarioId?: IntFilter<"Donacion"> | number
    monto?: FloatFilter<"Donacion"> | number
    fecha?: DateTimeFilter<"Donacion"> | Date | string
    tipo?: StringFilter<"Donacion"> | string
  }

  export type VoluntariadoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: VoluntariadoWhereUniqueInput
    update: XOR<VoluntariadoUpdateWithoutUsuarioInput, VoluntariadoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<VoluntariadoCreateWithoutUsuarioInput, VoluntariadoUncheckedCreateWithoutUsuarioInput>
  }

  export type VoluntariadoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: VoluntariadoWhereUniqueInput
    data: XOR<VoluntariadoUpdateWithoutUsuarioInput, VoluntariadoUncheckedUpdateWithoutUsuarioInput>
  }

  export type VoluntariadoUpdateManyWithWhereWithoutUsuarioInput = {
    where: VoluntariadoScalarWhereInput
    data: XOR<VoluntariadoUpdateManyMutationInput, VoluntariadoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type VoluntariadoScalarWhereInput = {
    AND?: VoluntariadoScalarWhereInput | VoluntariadoScalarWhereInput[]
    OR?: VoluntariadoScalarWhereInput[]
    NOT?: VoluntariadoScalarWhereInput | VoluntariadoScalarWhereInput[]
    id?: IntFilter<"Voluntariado"> | number
    usuarioId?: IntFilter<"Voluntariado"> | number
    actividad?: StringFilter<"Voluntariado"> | string
    fecha?: DateTimeFilter<"Voluntariado"> | Date | string
    estado?: StringFilter<"Voluntariado"> | string
  }

  export type RegistroMedicoUpsertWithWhereUniqueWithoutVeterinarioInput = {
    where: RegistroMedicoWhereUniqueInput
    update: XOR<RegistroMedicoUpdateWithoutVeterinarioInput, RegistroMedicoUncheckedUpdateWithoutVeterinarioInput>
    create: XOR<RegistroMedicoCreateWithoutVeterinarioInput, RegistroMedicoUncheckedCreateWithoutVeterinarioInput>
  }

  export type RegistroMedicoUpdateWithWhereUniqueWithoutVeterinarioInput = {
    where: RegistroMedicoWhereUniqueInput
    data: XOR<RegistroMedicoUpdateWithoutVeterinarioInput, RegistroMedicoUncheckedUpdateWithoutVeterinarioInput>
  }

  export type RegistroMedicoUpdateManyWithWhereWithoutVeterinarioInput = {
    where: RegistroMedicoScalarWhereInput
    data: XOR<RegistroMedicoUpdateManyMutationInput, RegistroMedicoUncheckedUpdateManyWithoutVeterinarioInput>
  }

  export type RegistroMedicoScalarWhereInput = {
    AND?: RegistroMedicoScalarWhereInput | RegistroMedicoScalarWhereInput[]
    OR?: RegistroMedicoScalarWhereInput[]
    NOT?: RegistroMedicoScalarWhereInput | RegistroMedicoScalarWhereInput[]
    id?: IntFilter<"RegistroMedico"> | number
    animalId?: IntFilter<"RegistroMedico"> | number
    veterinarioId?: IntFilter<"RegistroMedico"> | number
    descripcion?: StringFilter<"RegistroMedico"> | string
    fecha?: DateTimeFilter<"RegistroMedico"> | Date | string
    tipo?: StringFilter<"RegistroMedico"> | string
  }

  export type HogarTemporalUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: HogarTemporalWhereUniqueInput
    update: XOR<HogarTemporalUpdateWithoutUsuarioInput, HogarTemporalUncheckedUpdateWithoutUsuarioInput>
    create: XOR<HogarTemporalCreateWithoutUsuarioInput, HogarTemporalUncheckedCreateWithoutUsuarioInput>
  }

  export type HogarTemporalUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: HogarTemporalWhereUniqueInput
    data: XOR<HogarTemporalUpdateWithoutUsuarioInput, HogarTemporalUncheckedUpdateWithoutUsuarioInput>
  }

  export type HogarTemporalUpdateManyWithWhereWithoutUsuarioInput = {
    where: HogarTemporalScalarWhereInput
    data: XOR<HogarTemporalUpdateManyMutationInput, HogarTemporalUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type HogarTemporalScalarWhereInput = {
    AND?: HogarTemporalScalarWhereInput | HogarTemporalScalarWhereInput[]
    OR?: HogarTemporalScalarWhereInput[]
    NOT?: HogarTemporalScalarWhereInput | HogarTemporalScalarWhereInput[]
    id?: IntFilter<"HogarTemporal"> | number
    animalId?: IntFilter<"HogarTemporal"> | number
    usuarioId?: IntFilter<"HogarTemporal"> | number
    fechaInicio?: DateTimeFilter<"HogarTemporal"> | Date | string
    fechaFin?: DateTimeNullableFilter<"HogarTemporal"> | Date | string | null
    estado?: StringFilter<"HogarTemporal"> | string
  }

  export type AdopcionCreateWithoutAnimalInput = {
    fechaAdopcion?: Date | string
    estado: string
    usuario: UsuarioCreateNestedOneWithoutAdopcionesInput
  }

  export type AdopcionUncheckedCreateWithoutAnimalInput = {
    id?: number
    usuarioId: number
    fechaAdopcion?: Date | string
    estado: string
  }

  export type AdopcionCreateOrConnectWithoutAnimalInput = {
    where: AdopcionWhereUniqueInput
    create: XOR<AdopcionCreateWithoutAnimalInput, AdopcionUncheckedCreateWithoutAnimalInput>
  }

  export type AdopcionCreateManyAnimalInputEnvelope = {
    data: AdopcionCreateManyAnimalInput | AdopcionCreateManyAnimalInput[]
    skipDuplicates?: boolean
  }

  export type HistoriaExitoCreateWithoutAnimalInput = {
    titulo: string
    descripcion: string
    fecha?: Date | string
  }

  export type HistoriaExitoUncheckedCreateWithoutAnimalInput = {
    id?: number
    titulo: string
    descripcion: string
    fecha?: Date | string
  }

  export type HistoriaExitoCreateOrConnectWithoutAnimalInput = {
    where: HistoriaExitoWhereUniqueInput
    create: XOR<HistoriaExitoCreateWithoutAnimalInput, HistoriaExitoUncheckedCreateWithoutAnimalInput>
  }

  export type HistoriaExitoCreateManyAnimalInputEnvelope = {
    data: HistoriaExitoCreateManyAnimalInput | HistoriaExitoCreateManyAnimalInput[]
    skipDuplicates?: boolean
  }

  export type RegistroMedicoCreateWithoutAnimalInput = {
    descripcion: string
    fecha?: Date | string
    tipo: string
    veterinario: UsuarioCreateNestedOneWithoutRegistrosMedicosInput
  }

  export type RegistroMedicoUncheckedCreateWithoutAnimalInput = {
    id?: number
    veterinarioId: number
    descripcion: string
    fecha?: Date | string
    tipo: string
  }

  export type RegistroMedicoCreateOrConnectWithoutAnimalInput = {
    where: RegistroMedicoWhereUniqueInput
    create: XOR<RegistroMedicoCreateWithoutAnimalInput, RegistroMedicoUncheckedCreateWithoutAnimalInput>
  }

  export type RegistroMedicoCreateManyAnimalInputEnvelope = {
    data: RegistroMedicoCreateManyAnimalInput | RegistroMedicoCreateManyAnimalInput[]
    skipDuplicates?: boolean
  }

  export type HogarTemporalCreateWithoutAnimalInput = {
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
    usuario: UsuarioCreateNestedOneWithoutHogaresTemporalesInput
  }

  export type HogarTemporalUncheckedCreateWithoutAnimalInput = {
    id?: number
    usuarioId: number
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
  }

  export type HogarTemporalCreateOrConnectWithoutAnimalInput = {
    where: HogarTemporalWhereUniqueInput
    create: XOR<HogarTemporalCreateWithoutAnimalInput, HogarTemporalUncheckedCreateWithoutAnimalInput>
  }

  export type HogarTemporalCreateManyAnimalInputEnvelope = {
    data: HogarTemporalCreateManyAnimalInput | HogarTemporalCreateManyAnimalInput[]
    skipDuplicates?: boolean
  }

  export type AdopcionUpsertWithWhereUniqueWithoutAnimalInput = {
    where: AdopcionWhereUniqueInput
    update: XOR<AdopcionUpdateWithoutAnimalInput, AdopcionUncheckedUpdateWithoutAnimalInput>
    create: XOR<AdopcionCreateWithoutAnimalInput, AdopcionUncheckedCreateWithoutAnimalInput>
  }

  export type AdopcionUpdateWithWhereUniqueWithoutAnimalInput = {
    where: AdopcionWhereUniqueInput
    data: XOR<AdopcionUpdateWithoutAnimalInput, AdopcionUncheckedUpdateWithoutAnimalInput>
  }

  export type AdopcionUpdateManyWithWhereWithoutAnimalInput = {
    where: AdopcionScalarWhereInput
    data: XOR<AdopcionUpdateManyMutationInput, AdopcionUncheckedUpdateManyWithoutAnimalInput>
  }

  export type HistoriaExitoUpsertWithWhereUniqueWithoutAnimalInput = {
    where: HistoriaExitoWhereUniqueInput
    update: XOR<HistoriaExitoUpdateWithoutAnimalInput, HistoriaExitoUncheckedUpdateWithoutAnimalInput>
    create: XOR<HistoriaExitoCreateWithoutAnimalInput, HistoriaExitoUncheckedCreateWithoutAnimalInput>
  }

  export type HistoriaExitoUpdateWithWhereUniqueWithoutAnimalInput = {
    where: HistoriaExitoWhereUniqueInput
    data: XOR<HistoriaExitoUpdateWithoutAnimalInput, HistoriaExitoUncheckedUpdateWithoutAnimalInput>
  }

  export type HistoriaExitoUpdateManyWithWhereWithoutAnimalInput = {
    where: HistoriaExitoScalarWhereInput
    data: XOR<HistoriaExitoUpdateManyMutationInput, HistoriaExitoUncheckedUpdateManyWithoutAnimalInput>
  }

  export type HistoriaExitoScalarWhereInput = {
    AND?: HistoriaExitoScalarWhereInput | HistoriaExitoScalarWhereInput[]
    OR?: HistoriaExitoScalarWhereInput[]
    NOT?: HistoriaExitoScalarWhereInput | HistoriaExitoScalarWhereInput[]
    id?: IntFilter<"HistoriaExito"> | number
    animalId?: IntFilter<"HistoriaExito"> | number
    titulo?: StringFilter<"HistoriaExito"> | string
    descripcion?: StringFilter<"HistoriaExito"> | string
    fecha?: DateTimeFilter<"HistoriaExito"> | Date | string
  }

  export type RegistroMedicoUpsertWithWhereUniqueWithoutAnimalInput = {
    where: RegistroMedicoWhereUniqueInput
    update: XOR<RegistroMedicoUpdateWithoutAnimalInput, RegistroMedicoUncheckedUpdateWithoutAnimalInput>
    create: XOR<RegistroMedicoCreateWithoutAnimalInput, RegistroMedicoUncheckedCreateWithoutAnimalInput>
  }

  export type RegistroMedicoUpdateWithWhereUniqueWithoutAnimalInput = {
    where: RegistroMedicoWhereUniqueInput
    data: XOR<RegistroMedicoUpdateWithoutAnimalInput, RegistroMedicoUncheckedUpdateWithoutAnimalInput>
  }

  export type RegistroMedicoUpdateManyWithWhereWithoutAnimalInput = {
    where: RegistroMedicoScalarWhereInput
    data: XOR<RegistroMedicoUpdateManyMutationInput, RegistroMedicoUncheckedUpdateManyWithoutAnimalInput>
  }

  export type HogarTemporalUpsertWithWhereUniqueWithoutAnimalInput = {
    where: HogarTemporalWhereUniqueInput
    update: XOR<HogarTemporalUpdateWithoutAnimalInput, HogarTemporalUncheckedUpdateWithoutAnimalInput>
    create: XOR<HogarTemporalCreateWithoutAnimalInput, HogarTemporalUncheckedCreateWithoutAnimalInput>
  }

  export type HogarTemporalUpdateWithWhereUniqueWithoutAnimalInput = {
    where: HogarTemporalWhereUniqueInput
    data: XOR<HogarTemporalUpdateWithoutAnimalInput, HogarTemporalUncheckedUpdateWithoutAnimalInput>
  }

  export type HogarTemporalUpdateManyWithWhereWithoutAnimalInput = {
    where: HogarTemporalScalarWhereInput
    data: XOR<HogarTemporalUpdateManyMutationInput, HogarTemporalUncheckedUpdateManyWithoutAnimalInput>
  }

  export type AnimalCreateWithoutAdopcionesInput = {
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    historias?: HistoriaExitoCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateWithoutAdopcionesInput = {
    id?: number
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    historias?: HistoriaExitoUncheckedCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalCreateOrConnectWithoutAdopcionesInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutAdopcionesInput, AnimalUncheckedCreateWithoutAdopcionesInput>
  }

  export type UsuarioCreateWithoutAdopcionesInput = {
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    donaciones?: DonacionCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAdopcionesInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    donaciones?: DonacionUncheckedCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoUncheckedCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAdopcionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAdopcionesInput, UsuarioUncheckedCreateWithoutAdopcionesInput>
  }

  export type AnimalUpsertWithoutAdopcionesInput = {
    update: XOR<AnimalUpdateWithoutAdopcionesInput, AnimalUncheckedUpdateWithoutAdopcionesInput>
    create: XOR<AnimalCreateWithoutAdopcionesInput, AnimalUncheckedCreateWithoutAdopcionesInput>
    where?: AnimalWhereInput
  }

  export type AnimalUpdateToOneWithWhereWithoutAdopcionesInput = {
    where?: AnimalWhereInput
    data: XOR<AnimalUpdateWithoutAdopcionesInput, AnimalUncheckedUpdateWithoutAdopcionesInput>
  }

  export type AnimalUpdateWithoutAdopcionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    historias?: HistoriaExitoUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateWithoutAdopcionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    historias?: HistoriaExitoUncheckedUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type UsuarioUpsertWithoutAdopcionesInput = {
    update: XOR<UsuarioUpdateWithoutAdopcionesInput, UsuarioUncheckedUpdateWithoutAdopcionesInput>
    create: XOR<UsuarioCreateWithoutAdopcionesInput, UsuarioUncheckedCreateWithoutAdopcionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAdopcionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAdopcionesInput, UsuarioUncheckedUpdateWithoutAdopcionesInput>
  }

  export type UsuarioUpdateWithoutAdopcionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    donaciones?: DonacionUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAdopcionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    donaciones?: DonacionUncheckedUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUncheckedUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type AnimalCreateWithoutHistoriasInput = {
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateWithoutHistoriasInput = {
    id?: number
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalCreateOrConnectWithoutHistoriasInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutHistoriasInput, AnimalUncheckedCreateWithoutHistoriasInput>
  }

  export type AnimalUpsertWithoutHistoriasInput = {
    update: XOR<AnimalUpdateWithoutHistoriasInput, AnimalUncheckedUpdateWithoutHistoriasInput>
    create: XOR<AnimalCreateWithoutHistoriasInput, AnimalUncheckedCreateWithoutHistoriasInput>
    where?: AnimalWhereInput
  }

  export type AnimalUpdateToOneWithWhereWithoutHistoriasInput = {
    where?: AnimalWhereInput
    data: XOR<AnimalUpdateWithoutHistoriasInput, AnimalUncheckedUpdateWithoutHistoriasInput>
  }

  export type AnimalUpdateWithoutHistoriasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateWithoutHistoriasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUncheckedUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type UsuarioCreateWithoutDonacionesInput = {
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDonacionesInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoUncheckedCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDonacionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDonacionesInput, UsuarioUncheckedCreateWithoutDonacionesInput>
  }

  export type UsuarioUpsertWithoutDonacionesInput = {
    update: XOR<UsuarioUpdateWithoutDonacionesInput, UsuarioUncheckedUpdateWithoutDonacionesInput>
    create: XOR<UsuarioCreateWithoutDonacionesInput, UsuarioUncheckedCreateWithoutDonacionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutDonacionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutDonacionesInput, UsuarioUncheckedUpdateWithoutDonacionesInput>
  }

  export type UsuarioUpdateWithoutDonacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDonacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUncheckedUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUncheckedUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type AnimalCreateWithoutRegistrosMedicosInput = {
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionCreateNestedManyWithoutAnimalInput
    historias?: HistoriaExitoCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateWithoutRegistrosMedicosInput = {
    id?: number
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutAnimalInput
    historias?: HistoriaExitoUncheckedCreateNestedManyWithoutAnimalInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalCreateOrConnectWithoutRegistrosMedicosInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutRegistrosMedicosInput, AnimalUncheckedCreateWithoutRegistrosMedicosInput>
  }

  export type UsuarioCreateWithoutRegistrosMedicosInput = {
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoCreateNestedManyWithoutUsuarioInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutRegistrosMedicosInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionUncheckedCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoUncheckedCreateNestedManyWithoutUsuarioInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutRegistrosMedicosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutRegistrosMedicosInput, UsuarioUncheckedCreateWithoutRegistrosMedicosInput>
  }

  export type AnimalUpsertWithoutRegistrosMedicosInput = {
    update: XOR<AnimalUpdateWithoutRegistrosMedicosInput, AnimalUncheckedUpdateWithoutRegistrosMedicosInput>
    create: XOR<AnimalCreateWithoutRegistrosMedicosInput, AnimalUncheckedCreateWithoutRegistrosMedicosInput>
    where?: AnimalWhereInput
  }

  export type AnimalUpdateToOneWithWhereWithoutRegistrosMedicosInput = {
    where?: AnimalWhereInput
    data: XOR<AnimalUpdateWithoutRegistrosMedicosInput, AnimalUncheckedUpdateWithoutRegistrosMedicosInput>
  }

  export type AnimalUpdateWithoutRegistrosMedicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUpdateManyWithoutAnimalNestedInput
    historias?: HistoriaExitoUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateWithoutRegistrosMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUncheckedUpdateManyWithoutAnimalNestedInput
    historias?: HistoriaExitoUncheckedUpdateManyWithoutAnimalNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type UsuarioUpsertWithoutRegistrosMedicosInput = {
    update: XOR<UsuarioUpdateWithoutRegistrosMedicosInput, UsuarioUncheckedUpdateWithoutRegistrosMedicosInput>
    create: XOR<UsuarioCreateWithoutRegistrosMedicosInput, UsuarioUncheckedCreateWithoutRegistrosMedicosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutRegistrosMedicosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutRegistrosMedicosInput, UsuarioUncheckedUpdateWithoutRegistrosMedicosInput>
  }

  export type UsuarioUpdateWithoutRegistrosMedicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUpdateManyWithoutUsuarioNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutRegistrosMedicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUncheckedUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUncheckedUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUncheckedUpdateManyWithoutUsuarioNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutVoluntariadosInput = {
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutVoluntariadosInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionUncheckedCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutVeterinarioInput
    hogaresTemporales?: HogarTemporalUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutVoluntariadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutVoluntariadosInput, UsuarioUncheckedCreateWithoutVoluntariadosInput>
  }

  export type UsuarioUpsertWithoutVoluntariadosInput = {
    update: XOR<UsuarioUpdateWithoutVoluntariadosInput, UsuarioUncheckedUpdateWithoutVoluntariadosInput>
    create: XOR<UsuarioCreateWithoutVoluntariadosInput, UsuarioUncheckedCreateWithoutVoluntariadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutVoluntariadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutVoluntariadosInput, UsuarioUncheckedUpdateWithoutVoluntariadosInput>
  }

  export type UsuarioUpdateWithoutVoluntariadosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutVoluntariadosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUncheckedUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUncheckedUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutVeterinarioNestedInput
    hogaresTemporales?: HogarTemporalUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type AnimalCreateWithoutHogaresTemporalesInput = {
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionCreateNestedManyWithoutAnimalInput
    historias?: HistoriaExitoCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutAnimalInput
  }

  export type AnimalUncheckedCreateWithoutHogaresTemporalesInput = {
    id?: number
    nombre: string
    especie: string
    raza?: string | null
    edad?: number | null
    estado: string
    fechaIngreso?: Date | string
    descripcion?: string | null
    foto?: string | null
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutAnimalInput
    historias?: HistoriaExitoUncheckedCreateNestedManyWithoutAnimalInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutAnimalInput
  }

  export type AnimalCreateOrConnectWithoutHogaresTemporalesInput = {
    where: AnimalWhereUniqueInput
    create: XOR<AnimalCreateWithoutHogaresTemporalesInput, AnimalUncheckedCreateWithoutHogaresTemporalesInput>
  }

  export type UsuarioCreateWithoutHogaresTemporalesInput = {
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoCreateNestedManyWithoutVeterinarioInput
  }

  export type UsuarioUncheckedCreateWithoutHogaresTemporalesInput = {
    id?: number
    nombre: string
    apellido?: string | null
    email: string
    telefono?: string | null
    tipoUsuario: string
    estado: string
    avatar?: string | null
    password: string
    fechaRegistro?: Date | string
    adopciones?: AdopcionUncheckedCreateNestedManyWithoutUsuarioInput
    donaciones?: DonacionUncheckedCreateNestedManyWithoutUsuarioInput
    voluntariados?: VoluntariadoUncheckedCreateNestedManyWithoutUsuarioInput
    registrosMedicos?: RegistroMedicoUncheckedCreateNestedManyWithoutVeterinarioInput
  }

  export type UsuarioCreateOrConnectWithoutHogaresTemporalesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutHogaresTemporalesInput, UsuarioUncheckedCreateWithoutHogaresTemporalesInput>
  }

  export type AnimalUpsertWithoutHogaresTemporalesInput = {
    update: XOR<AnimalUpdateWithoutHogaresTemporalesInput, AnimalUncheckedUpdateWithoutHogaresTemporalesInput>
    create: XOR<AnimalCreateWithoutHogaresTemporalesInput, AnimalUncheckedCreateWithoutHogaresTemporalesInput>
    where?: AnimalWhereInput
  }

  export type AnimalUpdateToOneWithWhereWithoutHogaresTemporalesInput = {
    where?: AnimalWhereInput
    data: XOR<AnimalUpdateWithoutHogaresTemporalesInput, AnimalUncheckedUpdateWithoutHogaresTemporalesInput>
  }

  export type AnimalUpdateWithoutHogaresTemporalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUpdateManyWithoutAnimalNestedInput
    historias?: HistoriaExitoUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutAnimalNestedInput
  }

  export type AnimalUncheckedUpdateWithoutHogaresTemporalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    especie?: StringFieldUpdateOperationsInput | string
    raza?: NullableStringFieldUpdateOperationsInput | string | null
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: StringFieldUpdateOperationsInput | string
    fechaIngreso?: DateTimeFieldUpdateOperationsInput | Date | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    adopciones?: AdopcionUncheckedUpdateManyWithoutAnimalNestedInput
    historias?: HistoriaExitoUncheckedUpdateManyWithoutAnimalNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutAnimalNestedInput
  }

  export type UsuarioUpsertWithoutHogaresTemporalesInput = {
    update: XOR<UsuarioUpdateWithoutHogaresTemporalesInput, UsuarioUncheckedUpdateWithoutHogaresTemporalesInput>
    create: XOR<UsuarioCreateWithoutHogaresTemporalesInput, UsuarioUncheckedCreateWithoutHogaresTemporalesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutHogaresTemporalesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutHogaresTemporalesInput, UsuarioUncheckedUpdateWithoutHogaresTemporalesInput>
  }

  export type UsuarioUpdateWithoutHogaresTemporalesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUpdateManyWithoutVeterinarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutHogaresTemporalesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoUsuario?: StringFieldUpdateOperationsInput | string
    estado?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    fechaRegistro?: DateTimeFieldUpdateOperationsInput | Date | string
    adopciones?: AdopcionUncheckedUpdateManyWithoutUsuarioNestedInput
    donaciones?: DonacionUncheckedUpdateManyWithoutUsuarioNestedInput
    voluntariados?: VoluntariadoUncheckedUpdateManyWithoutUsuarioNestedInput
    registrosMedicos?: RegistroMedicoUncheckedUpdateManyWithoutVeterinarioNestedInput
  }

  export type AdopcionCreateManyUsuarioInput = {
    id?: number
    animalId: number
    fechaAdopcion?: Date | string
    estado: string
  }

  export type DonacionCreateManyUsuarioInput = {
    id?: number
    monto: number
    fecha?: Date | string
    tipo: string
  }

  export type VoluntariadoCreateManyUsuarioInput = {
    id?: number
    actividad: string
    fecha?: Date | string
    estado: string
  }

  export type RegistroMedicoCreateManyVeterinarioInput = {
    id?: number
    animalId: number
    descripcion: string
    fecha?: Date | string
    tipo: string
  }

  export type HogarTemporalCreateManyUsuarioInput = {
    id?: number
    animalId: number
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
  }

  export type AdopcionUpdateWithoutUsuarioInput = {
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    animal?: AnimalUpdateOneRequiredWithoutAdopcionesNestedInput
  }

  export type AdopcionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AdopcionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type DonacionUpdateWithoutUsuarioInput = {
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type DonacionUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type DonacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    monto?: FloatFieldUpdateOperationsInput | number
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type VoluntariadoUpdateWithoutUsuarioInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type VoluntariadoUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type VoluntariadoUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroMedicoUpdateWithoutVeterinarioInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    animal?: AnimalUpdateOneRequiredWithoutRegistrosMedicosNestedInput
  }

  export type RegistroMedicoUncheckedUpdateWithoutVeterinarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroMedicoUncheckedUpdateManyWithoutVeterinarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalUpdateWithoutUsuarioInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    animal?: AnimalUpdateOneRequiredWithoutHogaresTemporalesNestedInput
  }

  export type HogarTemporalUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    animalId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AdopcionCreateManyAnimalInput = {
    id?: number
    usuarioId: number
    fechaAdopcion?: Date | string
    estado: string
  }

  export type HistoriaExitoCreateManyAnimalInput = {
    id?: number
    titulo: string
    descripcion: string
    fecha?: Date | string
  }

  export type RegistroMedicoCreateManyAnimalInput = {
    id?: number
    veterinarioId: number
    descripcion: string
    fecha?: Date | string
    tipo: string
  }

  export type HogarTemporalCreateManyAnimalInput = {
    id?: number
    usuarioId: number
    fechaInicio: Date | string
    fechaFin?: Date | string | null
    estado: string
  }

  export type AdopcionUpdateWithoutAnimalInput = {
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutAdopcionesNestedInput
  }

  export type AdopcionUncheckedUpdateWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type AdopcionUncheckedUpdateManyWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaAdopcion?: DateTimeFieldUpdateOperationsInput | Date | string
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HistoriaExitoUpdateWithoutAnimalInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoriaExitoUncheckedUpdateWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistoriaExitoUncheckedUpdateManyWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroMedicoUpdateWithoutAnimalInput = {
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
    veterinario?: UsuarioUpdateOneRequiredWithoutRegistrosMedicosNestedInput
  }

  export type RegistroMedicoUncheckedUpdateWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    veterinarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroMedicoUncheckedUpdateManyWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    veterinarioId?: IntFieldUpdateOperationsInput | number
    descripcion?: StringFieldUpdateOperationsInput | string
    fecha?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalUpdateWithoutAnimalInput = {
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutHogaresTemporalesNestedInput
  }

  export type HogarTemporalUncheckedUpdateWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }

  export type HogarTemporalUncheckedUpdateManyWithoutAnimalInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuarioId?: IntFieldUpdateOperationsInput | number
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}